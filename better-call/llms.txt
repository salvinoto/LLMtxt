================================================
File: README.md
================================================
# Better Call

Better call is a tiny web framework for creating endpoints that can be invoked as a normal function or mounted to a router to be served by any web standard compatible server (like Bun, node, nextjs, sveltekit...) and also includes a typed RPC client for typesafe client-side invocation of these endpoints.

Built for typescript and it comes with a very high performance router based on [rou3](https://github.com/unjs/rou3).

## Install

```bash
pnpm i better-call
```

Make sure to install [standard schema](https://github.com/standard-schema/standard-schema) compatible validation library like zod.

```bash
pnpm i zod
```

## Usage

The building blocks for better-call are endpoints. You can create an endpoint by calling `createEndpoint` and passing it a path, [options](#endpointoptions) and a handler that will be invoked when the endpoint is called.

```ts
import { createEndpoint, createRouter } from "better-call"
import { z } from "zod"

const createItem = createEndpoint("/item", {
    method: "POST",
    body: z.object({
        id: z.string()
    })
}, async (ctx) => {
    return {
        item: {
            id: ctx.body.id
        }
    }
})

// Now you can call the endpoint just as a normal function.
const item = await createItem({
    body: {
        id: "123"
    }
})
```

OR you can mount the endpoint to a router and serve it with any web standard compatible server. 

> The example below uses [Bun](https://bun.sh/)

```ts
const router = createRouter({
    createItem
})

Bun.serve({
    fetch: router.handler
})
```

Then you can use the rpc client to call the endpoints on client.

```ts
//client.ts
import type { router } from "./router" // import router type
import { createClient } from "better-call/client";

const client = createClient<typeof router>({
    baseURL: "http://localhost:3000"
});
const items = await client("/item", {
    body: {
        id: "123"
    }
});
```

### Returning non 200 responses

To return a non 200 response, you will need to throw Better Call's `APIError` error. If the endpoint is called as a function, the error will be thrown but if it's mounted to a router, the error will be converted to a response object with the correct status code and headers.

```ts
const createItem = createEndpoint("/item", {
    method: "POST",
    body: z.object({
        id: z.string()
    })
}, async (ctx) => {
    if(ctx.body.id === "123") {
        throw ctx.error("Bad Request", {
            message: "Id is not allowed"
        })
    }
    return {
        item: {
            id: ctx.body.id
        }
    }
})
```

You can also instead throw using a status code:

```ts
const createItem = createEndpoint("/item", {
    method: "POST",
    body: z.object({
        id: z.string()
    })
}, async (ctx) => {
    if(ctx.body.id === "123") {
        throw ctx.error(400, {
            message: "Id is not allowed"
        })
    }
    return {
        item: {
            id: ctx.body.id
        }
    }
})
```

### Endpoint

Endpoints are building blocks of better-call. 

#### Path

The path is the URL path that the endpoint will respond to. It can be a direct path or a path with parameters and wildcards.

```ts
//direct path
const endpoint = createEndpoint("/item", {
    method: "GET",
}, async (ctx) => {})

//path with parameters
const endpoint = createEndpoint("/item/:id", {
    method: "GET",
}, async (ctx) => {
    return {
        item: {
            id: ctx.params.id
        }
    }
})

//path with wildcards
const endpoint = createEndpoint("/item/**:name", {
    method: "GET",  
}, async (ctx) => {
    //the name will be the remaining path
    ctx.params.name
})
```

#### Body Schema

The `body` option accepts a standard schema and will validate the request body. If the request body doesn't match the schema, the endpoint will throw an error. If it's mounted to a router, it'll return a 400 error.

```ts
const createItem = createEndpoint("/item", {
    method: "POST",
    body: z.object({
        id: z.string()
    })
}, async (ctx) => {
    return {
        item: {
            id: ctx.body.id
        }
    }
})
```

#### Query Schema

The `query` option accepts a standard schema and will validate the request query. If the request query doesn't match the schema, the endpoint will throw an error. If it's mounted to a router, it'll return a 400 error.

```ts
const createItem = createEndpoint("/item", {
    method: "GET",
    query: z.object({
        id: z.string()
    })
}, async (ctx) => {
    return {
        item: {
            id: ctx.query.id
        }
    }
})
```

#### Require Headers

The `requireHeaders` option is used to require the request to have headers. If the request doesn't have headers, the endpoint will throw an error. This is only useful when you call the endpoint as a function.

```ts
const createItem = createEndpoint("/item", {
    method: "GET",
    requireHeaders: true
}, async (ctx) => {
    return {
        item: {
            id: ctx.headers.get("id")
        }
    }
})
createItem({
    headers: new Headers()
})
```

#### Require Request

The `requireRequest` option is used to require the request to have a request object. If the request doesn't have a request object, the endpoint will throw an error. This is only useful when you call the endpoint as a function.

```ts
const createItem = createEndpoint("/item", {
    method: "GET",
    requireRequest: true
}, async (ctx) => {
    return {
        item: {
            id: ctx.request.id
        }
    }
})

createItem({
    request: new Request()
})
```

### Handler

this is the function that will be invoked when the endpoint is called. It accepts a context object that contains the request, headers, body, query, params and other information. 

It can return a response object, a string, a number, a boolean, an object or an array. 

It can also throw an error and if it throws APIError, it will be converted to a response object with the correct status code and headers.

- **Context**: the context object contains the request, headers, body, query, params and a helper function to set headers, cookies and get cookies. If there is a middleware, the context will be extended with the middleware context.

### Middleware

Endpoints can use middleware by passing the `use` option to the endpoint. To create a middleware, you can call `createMiddleware` and pass it a function or an options object and a handler function.

If you return a context object from the middleware, it will be available in the endpoint context.

```ts
import { createMiddleware, createEndpoint } from "better-call";

const middleware = createMiddleware(async (ctx) => {
    return {
        name: "hello"
    }
})

const endpoint = createEndpoint("/", {
    method: "GET",
    use: [middleware],
}, async (ctx) => {
   //this will be the context object returned by the middleware with the name property
   ctx.context
})
```

### Router

You can create a router by calling `createRouter` and passing it an array of endpoints. It returns a router object that has a `handler` method that can be used to serve the endpoints.

```ts
import { createRouter } from "better-call"
import { createItem } from "./item"

const router = createRouter({
    createItem
})

Bun.serve({
    fetch: router.handler
})
```

Behind the scenes, the router uses [rou3](https://github.com/unjs/rou3) to match the endpoints and invoke the correct endpoint. You can look at the [rou3 documentation](https://github.com/unjs/rou3) for more information.

#### Router Options

**routerMiddleware:**

A router middleware is similar to an endpoint middleware but it's applied to any path that matches the route. It's like any traditional middleware. You have to pass endpoints to the router middleware as an array.

```ts
const routeMiddleware = createEndpoint("/api/**", {
    method: "GET",
}, async (ctx) => {
    return {
        name: "hello"
    }
})
const router = createRouter({
    createItem
}, {
    routerMiddleware: [{
        path: "/api/**",
        middleware:routeMiddleware
    }]
})
```

**basePath**: The base path for the router. All paths will be relative to this path.

**onError**: The router will call this function if an error occurs in the middleware or the endpoint.

**throwError**: If true, the router will throw an error if an error occurs in the middleware or the endpoint.

#### Node Adapter

You can use the node adapter to serve the router with node http server.

```ts
import { createRouter } from "better-call";
import { toNodeHandler } from "better-call/node";
import { createItem } from "./item";
import http from "http";

const router = createRouter({
    createItem
})
const server = http.createServer(toNodeHandler(router.handler))
```

### RPC Client

better-call comes with a rpc client that can be used to call endpoints from the client. The client wraps over better-fetch so you can pass any options that are supported by better-fetch.

```ts
import { createClient } from "better-call/client";
import { router } from "@serve/router";

const client = createClient<typeof router>({
    /**
     * if you add custom path like `http://
     * localhost:3000/api` make sure to add the 
     * custom path on the router config as well.
    */
    baseURL: "http://localhost:3000"
});
const items = await client("/item", {
    body: {
        id: "123"
    }
});
```
> You can also pass object that contains endpoints as a generic type to create client.

### Headers and Cookies

If you return a response object from an endpoint, the headers and cookies will be set on the response object. But You can  set headers and cookies for the context object.

```ts
const createItem = createEndpoint("/item", {
    method: "POST",
    body: z.object({
        id: z.string()
    })
}, async (ctx) => {
    ctx.setHeader("X-Custom-Header", "Hello World")
    ctx.setCookie("my-cookie", "hello world")
    return {
        item: {
            id: ctx.body.id
        }
    }
})
```
 
You can also get cookies from the context object.

```ts
const createItem = createEndpoint("/item", {
    method: "POST",
    body: z.object({
        id: z.string()
    })
}, async (ctx) => {
    const cookie = ctx.getCookie("my-cookie")
    return {
        item: {
            id: ctx.body.id
        }
    }
})
```

> other than normal cookies the ctx object also exposes signed cookies.

### Endpoint Creator

You can create an endpoint creator by calling `createEndpoint.create` that will let you apply set of middlewares to all the endpoints created by the creator.

```ts
const dbMiddleware = createMiddleware(async (ctx) => {
   return {
    db: new Database()
   }
})
const create = createEndpoint.create({
    use: [dbMiddleware]
})

const createItem = create("/item", {
    method: "POST",
    body: z.object({
        id: z.string()
    })
}, async (ctx) => {
    await ctx.context.db.save(ctx.body)
})
```

### Open API

Better Call by default generate open api schema for the endpoints and exposes it on `/api/reference` path using scalar. By default, if you're using `zod` it'll be able to generate `body` and `query` schema.

```ts
import { createEndpoint, createRouter } from "better-call"

const createItem = createEndpoint("/item/:id", {
    method: "GET",
    query: z.object({
        id: z.string({
            description: "The id of the item"
        })
    })
}, async (ctx) => {
    return {
        item: {
            id: ctx.query.id
        }
    }
})
```

But you can also define custom schema for the open api schema.

```ts
import { createEndpoint, createRouter } from "better-call"

const createItem = createEndpoint("/item/:id", {
    method: "GET",
    query: z.object({
        id: z.string({
            description: "The id of the item"
        })
    }),
    metadata: {
    openapi: {
        requestBody: {
            content: {
                "application/json": {
                    schema: {
                        type: "object",
                        properties: {
                            id: {
                                type: "string",
                                description: "The id of the item"
                            }
                        }
                    }
                }
            }
        }
    }
   }
}, async (ctx) => {
    return {
        item: {
            id: ctx.query.id
        }
    }
})
```

#### Configuration

You can configure the open api schema by passing the `openapi` option to the router.

```ts
const router = createRouter({
    createItem
}, {
    openapi: {
        disabled: false, //default false
        path: "/api/reference", //default /api/reference
        scalar: {
            title: "My API",
            version: "1.0.0",
            description: "My API Description",
            theme: "dark" //default saturn
        }
    }
})
```

## License
MIT


================================================
File: biome.json
================================================
{
	"$schema": "https://biomejs.dev/schemas/1.8.3/schema.json",
	"formatter": {
		"enabled": true,
		"indentStyle": "tab",
		"lineWidth": 100,
		"indentWidth": 4
	},
	"linter": {
		"enabled": false
	},
	"files": {
		"ignore": ["dist", ".next", ".svelte-kit", "package.json", ".contentlayer"]
	}
}



================================================
File: package.json
================================================
{
  "name": "better-call",
  "version": "1.0.5",
  "packageManager": "pnpm@9.15.0",
  "type": "module",
  "main": "./dist/index.cjs",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "scripts": {
    "test": "vitest",
    "lint": "biome format",
    "lint:fix": "biome format --fix",
    "format": "biome format --write",
    "typecheck": "tsc --noEmit",
    "bump": "bumpp",
    "build": "tsup --dts --clean",
    "dev": "tsup --watch",
    "dev:dts": "tsup --watch --dts",
    "serve": "bun --hot example/hello.ts"
  },
  "devDependencies": {
    "@arethetypeswrong/cli": "^0.16.4",
    "@biomejs/biome": "^1.8.3",
    "@types/bun": "latest",
    "@types/set-cookie-parser": "^2.4.10",
    "arktype": "^2.0.0",
    "bumpp": "^9.4.1",
    "tsup": "^8.3.5",
    "type-fest": "^4.23.0",
    "typescript": "^5.6.0-beta",
    "valibot": "1.0.0-beta.15",
    "vitest": "^3.0.3",
    "zod": "^3.24.1"
  },
  "dependencies": {
    "@better-fetch/fetch": "^1.1.4",
    "rou3": "^0.5.1",
    "set-cookie-parser": "^2.7.1",
    "uncrypto": "^0.1.3"
  },
  "exports": {
    ".": {
      "import": {
        "types": "./dist/index.d.ts",
        "default": "./dist/index.js"
      },
      "require": {
        "types": "./dist/index.d.cts",
        "default": "./dist/index.cjs"
      }
    },
    "./client": {
      "import": {
        "types": "./dist/client.d.ts",
        "default": "./dist/client.js"
      },
      "require": {
        "types": "./dist/client.d.cts",
        "default": "./dist/client.cjs"
      }
    },
    "./node": {
      "import": {
        "types": "./dist/node.d.ts",
        "default": "./dist/node.js"
      },
      "require": {
        "types": "./dist/node.d.cts",
        "default": "./dist/node.cjs"
      }
    }
  },
  "files": [
    "dist"
  ]
}


================================================
File: pnpm-lock.yaml
================================================
lockfileVersion: '9.0'

settings:
  autoInstallPeers: true
  excludeLinksFromLockfile: false

importers:

  .:
    dependencies:
      '@better-fetch/fetch':
        specifier: ^1.1.4
        version: 1.1.12
      rou3:
        specifier: ^0.5.1
        version: 0.5.1
      set-cookie-parser:
        specifier: ^2.7.1
        version: 2.7.1
      uncrypto:
        specifier: ^0.1.3
        version: 0.1.3
    devDependencies:
      '@arethetypeswrong/cli':
        specifier: ^0.16.4
        version: 0.16.4
      '@biomejs/biome':
        specifier: ^1.8.3
        version: 1.9.4
      '@types/bun':
        specifier: latest
        version: 1.1.18
      '@types/set-cookie-parser':
        specifier: ^2.4.10
        version: 2.4.10
      arktype:
        specifier: ^2.0.0
        version: 2.0.0
      bumpp:
        specifier: ^9.4.1
        version: 9.10.1
      tsup:
        specifier: ^8.3.5
        version: 8.3.5(jiti@2.4.2)(postcss@8.5.1)(typescript@5.7.3)
      type-fest:
        specifier: ^4.23.0
        version: 4.33.0
      typescript:
        specifier: ^5.6.0-beta
        version: 5.7.3
      valibot:
        specifier: 1.0.0-beta.15
        version: 1.0.0-beta.15(typescript@5.7.3)
      vitest:
        specifier: ^3.0.3
        version: 3.0.3(@types/node@22.10.7)
      zod:
        specifier: ^3.24.1
        version: 3.24.1

packages:

  '@andrewbranch/untar.js@1.0.3':
    resolution: {integrity: sha512-Jh15/qVmrLGhkKJBdXlK1+9tY4lZruYjsgkDFj08ZmDiWVBLJcqkok7Z0/R0In+i1rScBpJlSvrTS2Lm41Pbnw==}

  '@arethetypeswrong/cli@0.16.4':
    resolution: {integrity: sha512-qMmdVlJon5FtA+ahn0c1oAVNxiq4xW5lqFiTZ21XHIeVwAVIQ+uRz4UEivqRMsjVV1grzRgJSKqaOrq1MvlVyQ==}
    engines: {node: '>=18'}
    hasBin: true

  '@arethetypeswrong/core@0.16.4':
    resolution: {integrity: sha512-RI3HXgSuKTfcBf1hSEg1P9/cOvmI0flsMm6/QL3L3wju4AlHDqd55JFPfXs4pzgEAgy5L9pul4/HPPz99x2GvA==}
    engines: {node: '>=18'}

  '@ark/schema@0.35.0':
    resolution: {integrity: sha512-cV3tiYpIFIt4JB4ZrXSUJ6v2nnAzbX5DqaNWRMpk4pVQV15HMEawg6wYn+JKEI16vfRCIcGqxxdGBvE0zIxqKw==}

  '@ark/util@0.35.0':
    resolution: {integrity: sha512-KxhwMOGMoV605zcqoBVyNFEtKAc3PKy95IWmVz9dwuUzIQ+sh7Bk9KEnlGPXcPAD8DCDs/10deHeO1kfWWONvg==}

  '@better-fetch/fetch@1.1.12':
    resolution: {integrity: sha512-B3bfloI/2UBQWIATRN6qmlORrvx3Mp0kkNjmXLv0b+DtbtR+pP4/I5kQA/rDUv+OReLywCCldf6co4LdDmh8JA==}

  '@biomejs/biome@1.9.4':
    resolution: {integrity: sha512-1rkd7G70+o9KkTn5KLmDYXihGoTaIGO9PIIN2ZB7UJxFrWw04CZHPYiMRjYsaDvVV7hP1dYNRLxSANLaBFGpog==}
    engines: {node: '>=14.21.3'}
    hasBin: true

  '@biomejs/cli-darwin-arm64@1.9.4':
    resolution: {integrity: sha512-bFBsPWrNvkdKrNCYeAp+xo2HecOGPAy9WyNyB/jKnnedgzl4W4Hb9ZMzYNbf8dMCGmUdSavlYHiR01QaYR58cw==}
    engines: {node: '>=14.21.3'}
    cpu: [arm64]
    os: [darwin]

  '@biomejs/cli-darwin-x64@1.9.4':
    resolution: {integrity: sha512-ngYBh/+bEedqkSevPVhLP4QfVPCpb+4BBe2p7Xs32dBgs7rh9nY2AIYUL6BgLw1JVXV8GlpKmb/hNiuIxfPfZg==}
    engines: {node: '>=14.21.3'}
    cpu: [x64]
    os: [darwin]

  '@biomejs/cli-linux-arm64-musl@1.9.4':
    resolution: {integrity: sha512-v665Ct9WCRjGa8+kTr0CzApU0+XXtRgwmzIf1SeKSGAv+2scAlW6JR5PMFo6FzqqZ64Po79cKODKf3/AAmECqA==}
    engines: {node: '>=14.21.3'}
    cpu: [arm64]
    os: [linux]

  '@biomejs/cli-linux-arm64@1.9.4':
    resolution: {integrity: sha512-fJIW0+LYujdjUgJJuwesP4EjIBl/N/TcOX3IvIHJQNsAqvV2CHIogsmA94BPG6jZATS4Hi+xv4SkBBQSt1N4/g==}
    engines: {node: '>=14.21.3'}
    cpu: [arm64]
    os: [linux]

  '@biomejs/cli-linux-x64-musl@1.9.4':
    resolution: {integrity: sha512-gEhi/jSBhZ2m6wjV530Yy8+fNqG8PAinM3oV7CyO+6c3CEh16Eizm21uHVsyVBEB6RIM8JHIl6AGYCv6Q6Q9Tg==}
    engines: {node: '>=14.21.3'}
    cpu: [x64]
    os: [linux]

  '@biomejs/cli-linux-x64@1.9.4':
    resolution: {integrity: sha512-lRCJv/Vi3Vlwmbd6K+oQ0KhLHMAysN8lXoCI7XeHlxaajk06u7G+UsFSO01NAs5iYuWKmVZjmiOzJ0OJmGsMwg==}
    engines: {node: '>=14.21.3'}
    cpu: [x64]
    os: [linux]

  '@biomejs/cli-win32-arm64@1.9.4':
    resolution: {integrity: sha512-tlbhLk+WXZmgwoIKwHIHEBZUwxml7bRJgk0X2sPyNR3S93cdRq6XulAZRQJ17FYGGzWne0fgrXBKpl7l4M87Hg==}
    engines: {node: '>=14.21.3'}
    cpu: [arm64]
    os: [win32]

  '@biomejs/cli-win32-x64@1.9.4':
    resolution: {integrity: sha512-8Y5wMhVIPaWe6jw2H+KlEm4wP/f7EW3810ZLmDlrEEy5KvBsb9ECEfu/kMWD484ijfQ8+nIi0giMgu9g1UAuuA==}
    engines: {node: '>=14.21.3'}
    cpu: [x64]
    os: [win32]

  '@colors/colors@1.5.0':
    resolution: {integrity: sha512-ooWCrlZP11i8GImSjTHYHLkvFDP48nS4+204nGb1RiX/WXYHmJA2III9/e2DWVabCESdW7hBAEzHRqUn9OUVvQ==}
    engines: {node: '>=0.1.90'}

  '@esbuild/aix-ppc64@0.21.5':
    resolution: {integrity: sha512-1SDgH6ZSPTlggy1yI6+Dbkiz8xzpHJEVAlF/AM1tHPLsf5STom9rwtjE4hKAF20FfXXNTFqEYXyJNWh1GiZedQ==}
    engines: {node: '>=12'}
    cpu: [ppc64]
    os: [aix]

  '@esbuild/aix-ppc64@0.24.2':
    resolution: {integrity: sha512-thpVCb/rhxE/BnMLQ7GReQLLN8q9qbHmI55F4489/ByVg2aQaQ6kbcLb6FHkocZzQhxc4gx0sCk0tJkKBFzDhA==}
    engines: {node: '>=18'}
    cpu: [ppc64]
    os: [aix]

  '@esbuild/android-arm64@0.21.5':
    resolution: {integrity: sha512-c0uX9VAUBQ7dTDCjq+wdyGLowMdtR/GoC2U5IYk/7D1H1JYC0qseD7+11iMP2mRLN9RcCMRcjC4YMclCzGwS/A==}
    engines: {node: '>=12'}
    cpu: [arm64]
    os: [android]

  '@esbuild/android-arm64@0.24.2':
    resolution: {integrity: sha512-cNLgeqCqV8WxfcTIOeL4OAtSmL8JjcN6m09XIgro1Wi7cF4t/THaWEa7eL5CMoMBdjoHOTh/vwTO/o2TRXIyzg==}
    engines: {node: '>=18'}
    cpu: [arm64]
    os: [android]

  '@esbuild/android-arm@0.21.5':
    resolution: {integrity: sha512-vCPvzSjpPHEi1siZdlvAlsPxXl7WbOVUBBAowWug4rJHb68Ox8KualB+1ocNvT5fjv6wpkX6o/iEpbDrf68zcg==}
    engines: {node: '>=12'}
    cpu: [arm]
    os: [android]

  '@esbuild/android-arm@0.24.2':
    resolution: {integrity: sha512-tmwl4hJkCfNHwFB3nBa8z1Uy3ypZpxqxfTQOcHX+xRByyYgunVbZ9MzUUfb0RxaHIMnbHagwAxuTL+tnNM+1/Q==}
    engines: {node: '>=18'}
    cpu: [arm]
    os: [android]

  '@esbuild/android-x64@0.21.5':
    resolution: {integrity: sha512-D7aPRUUNHRBwHxzxRvp856rjUHRFW1SdQATKXH2hqA0kAZb1hKmi02OpYRacl0TxIGz/ZmXWlbZgjwWYaCakTA==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [android]

  '@esbuild/android-x64@0.24.2':
    resolution: {integrity: sha512-B6Q0YQDqMx9D7rvIcsXfmJfvUYLoP722bgfBlO5cGvNVb5V/+Y7nhBE3mHV9OpxBf4eAS2S68KZztiPaWq4XYw==}
    engines: {node: '>=18'}
    cpu: [x64]
    os: [android]

  '@esbuild/darwin-arm64@0.21.5':
    resolution: {integrity: sha512-DwqXqZyuk5AiWWf3UfLiRDJ5EDd49zg6O9wclZ7kUMv2WRFr4HKjXp/5t8JZ11QbQfUS6/cRCKGwYhtNAY88kQ==}
    engines: {node: '>=12'}
    cpu: [arm64]
    os: [darwin]

  '@esbuild/darwin-arm64@0.24.2':
    resolution: {integrity: sha512-kj3AnYWc+CekmZnS5IPu9D+HWtUI49hbnyqk0FLEJDbzCIQt7hg7ucF1SQAilhtYpIujfaHr6O0UHlzzSPdOeA==}
    engines: {node: '>=18'}
    cpu: [arm64]
    os: [darwin]

  '@esbuild/darwin-x64@0.21.5':
    resolution: {integrity: sha512-se/JjF8NlmKVG4kNIuyWMV/22ZaerB+qaSi5MdrXtd6R08kvs2qCN4C09miupktDitvh8jRFflwGFBQcxZRjbw==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [darwin]

  '@esbuild/darwin-x64@0.24.2':
    resolution: {integrity: sha512-WeSrmwwHaPkNR5H3yYfowhZcbriGqooyu3zI/3GGpF8AyUdsrrP0X6KumITGA9WOyiJavnGZUwPGvxvwfWPHIA==}
    engines: {node: '>=18'}
    cpu: [x64]
    os: [darwin]

  '@esbuild/freebsd-arm64@0.21.5':
    resolution: {integrity: sha512-5JcRxxRDUJLX8JXp/wcBCy3pENnCgBR9bN6JsY4OmhfUtIHe3ZW0mawA7+RDAcMLrMIZaf03NlQiX9DGyB8h4g==}
    engines: {node: '>=12'}
    cpu: [arm64]
    os: [freebsd]

  '@esbuild/freebsd-arm64@0.24.2':
    resolution: {integrity: sha512-UN8HXjtJ0k/Mj6a9+5u6+2eZ2ERD7Edt1Q9IZiB5UZAIdPnVKDoG7mdTVGhHJIeEml60JteamR3qhsr1r8gXvg==}
    engines: {node: '>=18'}
    cpu: [arm64]
    os: [freebsd]

  '@esbuild/freebsd-x64@0.21.5':
    resolution: {integrity: sha512-J95kNBj1zkbMXtHVH29bBriQygMXqoVQOQYA+ISs0/2l3T9/kj42ow2mpqerRBxDJnmkUDCaQT/dfNXWX/ZZCQ==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [freebsd]

  '@esbuild/freebsd-x64@0.24.2':
    resolution: {integrity: sha512-TvW7wE/89PYW+IevEJXZ5sF6gJRDY/14hyIGFXdIucxCsbRmLUcjseQu1SyTko+2idmCw94TgyaEZi9HUSOe3Q==}
    engines: {node: '>=18'}
    cpu: [x64]
    os: [freebsd]

  '@esbuild/linux-arm64@0.21.5':
    resolution: {integrity: sha512-ibKvmyYzKsBeX8d8I7MH/TMfWDXBF3db4qM6sy+7re0YXya+K1cem3on9XgdT2EQGMu4hQyZhan7TeQ8XkGp4Q==}
    engines: {node: '>=12'}
    cpu: [arm64]
    os: [linux]

  '@esbuild/linux-arm64@0.24.2':
    resolution: {integrity: sha512-7HnAD6074BW43YvvUmE/35Id9/NB7BeX5EoNkK9obndmZBUk8xmJJeU7DwmUeN7tkysslb2eSl6CTrYz6oEMQg==}
    engines: {node: '>=18'}
    cpu: [arm64]
    os: [linux]

  '@esbuild/linux-arm@0.21.5':
    resolution: {integrity: sha512-bPb5AHZtbeNGjCKVZ9UGqGwo8EUu4cLq68E95A53KlxAPRmUyYv2D6F0uUI65XisGOL1hBP5mTronbgo+0bFcA==}
    engines: {node: '>=12'}
    cpu: [arm]
    os: [linux]

  '@esbuild/linux-arm@0.24.2':
    resolution: {integrity: sha512-n0WRM/gWIdU29J57hJyUdIsk0WarGd6To0s+Y+LwvlC55wt+GT/OgkwoXCXvIue1i1sSNWblHEig00GBWiJgfA==}
    engines: {node: '>=18'}
    cpu: [arm]
    os: [linux]

  '@esbuild/linux-ia32@0.21.5':
    resolution: {integrity: sha512-YvjXDqLRqPDl2dvRODYmmhz4rPeVKYvppfGYKSNGdyZkA01046pLWyRKKI3ax8fbJoK5QbxblURkwK/MWY18Tg==}
    engines: {node: '>=12'}
    cpu: [ia32]
    os: [linux]

  '@esbuild/linux-ia32@0.24.2':
    resolution: {integrity: sha512-sfv0tGPQhcZOgTKO3oBE9xpHuUqguHvSo4jl+wjnKwFpapx+vUDcawbwPNuBIAYdRAvIDBfZVvXprIj3HA+Ugw==}
    engines: {node: '>=18'}
    cpu: [ia32]
    os: [linux]

  '@esbuild/linux-loong64@0.21.5':
    resolution: {integrity: sha512-uHf1BmMG8qEvzdrzAqg2SIG/02+4/DHB6a9Kbya0XDvwDEKCoC8ZRWI5JJvNdUjtciBGFQ5PuBlpEOXQj+JQSg==}
    engines: {node: '>=12'}
    cpu: [loong64]
    os: [linux]

  '@esbuild/linux-loong64@0.24.2':
    resolution: {integrity: sha512-CN9AZr8kEndGooS35ntToZLTQLHEjtVB5n7dl8ZcTZMonJ7CCfStrYhrzF97eAecqVbVJ7APOEe18RPI4KLhwQ==}
    engines: {node: '>=18'}
    cpu: [loong64]
    os: [linux]

  '@esbuild/linux-mips64el@0.21.5':
    resolution: {integrity: sha512-IajOmO+KJK23bj52dFSNCMsz1QP1DqM6cwLUv3W1QwyxkyIWecfafnI555fvSGqEKwjMXVLokcV5ygHW5b3Jbg==}
    engines: {node: '>=12'}
    cpu: [mips64el]
    os: [linux]

  '@esbuild/linux-mips64el@0.24.2':
    resolution: {integrity: sha512-iMkk7qr/wl3exJATwkISxI7kTcmHKE+BlymIAbHO8xanq/TjHaaVThFF6ipWzPHryoFsesNQJPE/3wFJw4+huw==}
    engines: {node: '>=18'}
    cpu: [mips64el]
    os: [linux]

  '@esbuild/linux-ppc64@0.21.5':
    resolution: {integrity: sha512-1hHV/Z4OEfMwpLO8rp7CvlhBDnjsC3CttJXIhBi+5Aj5r+MBvy4egg7wCbe//hSsT+RvDAG7s81tAvpL2XAE4w==}
    engines: {node: '>=12'}
    cpu: [ppc64]
    os: [linux]

  '@esbuild/linux-ppc64@0.24.2':
    resolution: {integrity: sha512-shsVrgCZ57Vr2L8mm39kO5PPIb+843FStGt7sGGoqiiWYconSxwTiuswC1VJZLCjNiMLAMh34jg4VSEQb+iEbw==}
    engines: {node: '>=18'}
    cpu: [ppc64]
    os: [linux]

  '@esbuild/linux-riscv64@0.21.5':
    resolution: {integrity: sha512-2HdXDMd9GMgTGrPWnJzP2ALSokE/0O5HhTUvWIbD3YdjME8JwvSCnNGBnTThKGEB91OZhzrJ4qIIxk/SBmyDDA==}
    engines: {node: '>=12'}
    cpu: [riscv64]
    os: [linux]

  '@esbuild/linux-riscv64@0.24.2':
    resolution: {integrity: sha512-4eSFWnU9Hhd68fW16GD0TINewo1L6dRrB+oLNNbYyMUAeOD2yCK5KXGK1GH4qD/kT+bTEXjsyTCiJGHPZ3eM9Q==}
    engines: {node: '>=18'}
    cpu: [riscv64]
    os: [linux]

  '@esbuild/linux-s390x@0.21.5':
    resolution: {integrity: sha512-zus5sxzqBJD3eXxwvjN1yQkRepANgxE9lgOW2qLnmr8ikMTphkjgXu1HR01K4FJg8h1kEEDAqDcZQtbrRnB41A==}
    engines: {node: '>=12'}
    cpu: [s390x]
    os: [linux]

  '@esbuild/linux-s390x@0.24.2':
    resolution: {integrity: sha512-S0Bh0A53b0YHL2XEXC20bHLuGMOhFDO6GN4b3YjRLK//Ep3ql3erpNcPlEFed93hsQAjAQDNsvcK+hV90FubSw==}
    engines: {node: '>=18'}
    cpu: [s390x]
    os: [linux]

  '@esbuild/linux-x64@0.21.5':
    resolution: {integrity: sha512-1rYdTpyv03iycF1+BhzrzQJCdOuAOtaqHTWJZCWvijKD2N5Xu0TtVC8/+1faWqcP9iBCWOmjmhoH94dH82BxPQ==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [linux]

  '@esbuild/linux-x64@0.24.2':
    resolution: {integrity: sha512-8Qi4nQcCTbLnK9WoMjdC9NiTG6/E38RNICU6sUNqK0QFxCYgoARqVqxdFmWkdonVsvGqWhmm7MO0jyTqLqwj0Q==}
    engines: {node: '>=18'}
    cpu: [x64]
    os: [linux]

  '@esbuild/netbsd-arm64@0.24.2':
    resolution: {integrity: sha512-wuLK/VztRRpMt9zyHSazyCVdCXlpHkKm34WUyinD2lzK07FAHTq0KQvZZlXikNWkDGoT6x3TD51jKQ7gMVpopw==}
    engines: {node: '>=18'}
    cpu: [arm64]
    os: [netbsd]

  '@esbuild/netbsd-x64@0.21.5':
    resolution: {integrity: sha512-Woi2MXzXjMULccIwMnLciyZH4nCIMpWQAs049KEeMvOcNADVxo0UBIQPfSmxB3CWKedngg7sWZdLvLczpe0tLg==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [netbsd]

  '@esbuild/netbsd-x64@0.24.2':
    resolution: {integrity: sha512-VefFaQUc4FMmJuAxmIHgUmfNiLXY438XrL4GDNV1Y1H/RW3qow68xTwjZKfj/+Plp9NANmzbH5R40Meudu8mmw==}
    engines: {node: '>=18'}
    cpu: [x64]
    os: [netbsd]

  '@esbuild/openbsd-arm64@0.24.2':
    resolution: {integrity: sha512-YQbi46SBct6iKnszhSvdluqDmxCJA+Pu280Av9WICNwQmMxV7nLRHZfjQzwbPs3jeWnuAhE9Jy0NrnJ12Oz+0A==}
    engines: {node: '>=18'}
    cpu: [arm64]
    os: [openbsd]

  '@esbuild/openbsd-x64@0.21.5':
    resolution: {integrity: sha512-HLNNw99xsvx12lFBUwoT8EVCsSvRNDVxNpjZ7bPn947b8gJPzeHWyNVhFsaerc0n3TsbOINvRP2byTZ5LKezow==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [openbsd]

  '@esbuild/openbsd-x64@0.24.2':
    resolution: {integrity: sha512-+iDS6zpNM6EnJyWv0bMGLWSWeXGN/HTaF/LXHXHwejGsVi+ooqDfMCCTerNFxEkM3wYVcExkeGXNqshc9iMaOA==}
    engines: {node: '>=18'}
    cpu: [x64]
    os: [openbsd]

  '@esbuild/sunos-x64@0.21.5':
    resolution: {integrity: sha512-6+gjmFpfy0BHU5Tpptkuh8+uw3mnrvgs+dSPQXQOv3ekbordwnzTVEb4qnIvQcYXq6gzkyTnoZ9dZG+D4garKg==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [sunos]

  '@esbuild/sunos-x64@0.24.2':
    resolution: {integrity: sha512-hTdsW27jcktEvpwNHJU4ZwWFGkz2zRJUz8pvddmXPtXDzVKTTINmlmga3ZzwcuMpUvLw7JkLy9QLKyGpD2Yxig==}
    engines: {node: '>=18'}
    cpu: [x64]
    os: [sunos]

  '@esbuild/win32-arm64@0.21.5':
    resolution: {integrity: sha512-Z0gOTd75VvXqyq7nsl93zwahcTROgqvuAcYDUr+vOv8uHhNSKROyU961kgtCD1e95IqPKSQKH7tBTslnS3tA8A==}
    engines: {node: '>=12'}
    cpu: [arm64]
    os: [win32]

  '@esbuild/win32-arm64@0.24.2':
    resolution: {integrity: sha512-LihEQ2BBKVFLOC9ZItT9iFprsE9tqjDjnbulhHoFxYQtQfai7qfluVODIYxt1PgdoyQkz23+01rzwNwYfutxUQ==}
    engines: {node: '>=18'}
    cpu: [arm64]
    os: [win32]

  '@esbuild/win32-ia32@0.21.5':
    resolution: {integrity: sha512-SWXFF1CL2RVNMaVs+BBClwtfZSvDgtL//G/smwAc5oVK/UPu2Gu9tIaRgFmYFFKrmg3SyAjSrElf0TiJ1v8fYA==}
    engines: {node: '>=12'}
    cpu: [ia32]
    os: [win32]

  '@esbuild/win32-ia32@0.24.2':
    resolution: {integrity: sha512-q+iGUwfs8tncmFC9pcnD5IvRHAzmbwQ3GPS5/ceCyHdjXubwQWI12MKWSNSMYLJMq23/IUCvJMS76PDqXe1fxA==}
    engines: {node: '>=18'}
    cpu: [ia32]
    os: [win32]

  '@esbuild/win32-x64@0.21.5':
    resolution: {integrity: sha512-tQd/1efJuzPC6rCFwEvLtci/xNFcTZknmXs98FYDfGE4wP9ClFV98nyKrzJKVPMhdDnjzLhdUyMX4PsQAPjwIw==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [win32]

  '@esbuild/win32-x64@0.24.2':
    resolution: {integrity: sha512-7VTgWzgMGvup6aSqDPLiW5zHaxYJGTO4OokMjIlrCtf+VpEL+cXKtCvg723iguPYI5oaUNdS+/V7OU2gvXVWEg==}
    engines: {node: '>=18'}
    cpu: [x64]
    os: [win32]

  '@isaacs/cliui@8.0.2':
    resolution: {integrity: sha512-O8jcjabXaleOG9DQ0+ARXWZBTfnP4WNAqzuiJK7ll44AmxGKv/J2M4TPjxjY3znBCfvBXFzucm1twdyFybFqEA==}
    engines: {node: '>=12'}

  '@jridgewell/gen-mapping@0.3.8':
    resolution: {integrity: sha512-imAbBGkb+ebQyxKgzv5Hu2nmROxoDOXHh80evxdoXNOrvAnVx7zimzc1Oo5h9RlfV4vPXaE2iM5pOFbvOCClWA==}
    engines: {node: '>=6.0.0'}

  '@jridgewell/resolve-uri@3.1.2':
    resolution: {integrity: sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==}
    engines: {node: '>=6.0.0'}

  '@jridgewell/set-array@1.2.1':
    resolution: {integrity: sha512-R8gLRTZeyp03ymzP/6Lil/28tGeGEzhx1q2k703KGWRAI1VdvPIXdG70VJc2pAMw3NA6JKL5hhFu1sJX0Mnn/A==}
    engines: {node: '>=6.0.0'}

  '@jridgewell/sourcemap-codec@1.5.0':
    resolution: {integrity: sha512-gv3ZRaISU3fjPAgNsriBRqGWQL6quFx04YMPW/zD8XMLsU32mhCCbfbO6KZFLjvYpCZ8zyDEgqsgf+PwPaM7GQ==}

  '@jridgewell/trace-mapping@0.3.25':
    resolution: {integrity: sha512-vNk6aEwybGtawWmy/PzwnGDOjCkLWSD2wqvjGGAgOAwCGWySYXfYoxt00IJkTF+8Lb57DwOb3Aa0o9CApepiYQ==}

  '@pkgjs/parseargs@0.11.0':
    resolution: {integrity: sha512-+1VkjdD0QBLPodGrJUeqarH8VAIvQODIbwh9XpP5Syisf7YoQgsJKPNFoqqLQlu+VQ/tVSshMR6loPMn8U+dPg==}
    engines: {node: '>=14'}

  '@rollup/rollup-android-arm-eabi@4.31.0':
    resolution: {integrity: sha512-9NrR4033uCbUBRgvLcBrJofa2KY9DzxL2UKZ1/4xA/mnTNyhZCWBuD8X3tPm1n4KxcgaraOYgrFKSgwjASfmlA==}
    cpu: [arm]
    os: [android]

  '@rollup/rollup-android-arm64@4.31.0':
    resolution: {integrity: sha512-iBbODqT86YBFHajxxF8ebj2hwKm1k8PTBQSojSt3d1FFt1gN+xf4CowE47iN0vOSdnd+5ierMHBbu/rHc7nq5g==}
    cpu: [arm64]
    os: [android]

  '@rollup/rollup-darwin-arm64@4.31.0':
    resolution: {integrity: sha512-WHIZfXgVBX30SWuTMhlHPXTyN20AXrLH4TEeH/D0Bolvx9PjgZnn4H677PlSGvU6MKNsjCQJYczkpvBbrBnG6g==}
    cpu: [arm64]
    os: [darwin]

  '@rollup/rollup-darwin-x64@4.31.0':
    resolution: {integrity: sha512-hrWL7uQacTEF8gdrQAqcDy9xllQ0w0zuL1wk1HV8wKGSGbKPVjVUv/DEwT2+Asabf8Dh/As+IvfdU+H8hhzrQQ==}
    cpu: [x64]
    os: [darwin]

  '@rollup/rollup-freebsd-arm64@4.31.0':
    resolution: {integrity: sha512-S2oCsZ4hJviG1QjPY1h6sVJLBI6ekBeAEssYKad1soRFv3SocsQCzX6cwnk6fID6UQQACTjeIMB+hyYrFacRew==}
    cpu: [arm64]
    os: [freebsd]

  '@rollup/rollup-freebsd-x64@4.31.0':
    resolution: {integrity: sha512-pCANqpynRS4Jirn4IKZH4tnm2+2CqCNLKD7gAdEjzdLGbH1iO0zouHz4mxqg0uEMpO030ejJ0aA6e1PJo2xrPA==}
    cpu: [x64]
    os: [freebsd]

  '@rollup/rollup-linux-arm-gnueabihf@4.31.0':
    resolution: {integrity: sha512-0O8ViX+QcBd3ZmGlcFTnYXZKGbFu09EhgD27tgTdGnkcYXLat4KIsBBQeKLR2xZDCXdIBAlWLkiXE1+rJpCxFw==}
    cpu: [arm]
    os: [linux]

  '@rollup/rollup-linux-arm-musleabihf@4.31.0':
    resolution: {integrity: sha512-w5IzG0wTVv7B0/SwDnMYmbr2uERQp999q8FMkKG1I+j8hpPX2BYFjWe69xbhbP6J9h2gId/7ogesl9hwblFwwg==}
    cpu: [arm]
    os: [linux]

  '@rollup/rollup-linux-arm64-gnu@4.31.0':
    resolution: {integrity: sha512-JyFFshbN5xwy6fulZ8B/8qOqENRmDdEkcIMF0Zz+RsfamEW+Zabl5jAb0IozP/8UKnJ7g2FtZZPEUIAlUSX8cA==}
    cpu: [arm64]
    os: [linux]

  '@rollup/rollup-linux-arm64-musl@4.31.0':
    resolution: {integrity: sha512-kpQXQ0UPFeMPmPYksiBL9WS/BDiQEjRGMfklVIsA0Sng347H8W2iexch+IEwaR7OVSKtr2ZFxggt11zVIlZ25g==}
    cpu: [arm64]
    os: [linux]

  '@rollup/rollup-linux-loongarch64-gnu@4.31.0':
    resolution: {integrity: sha512-pMlxLjt60iQTzt9iBb3jZphFIl55a70wexvo8p+vVFK+7ifTRookdoXX3bOsRdmfD+OKnMozKO6XM4zR0sHRrQ==}
    cpu: [loong64]
    os: [linux]

  '@rollup/rollup-linux-powerpc64le-gnu@4.31.0':
    resolution: {integrity: sha512-D7TXT7I/uKEuWiRkEFbed1UUYZwcJDU4vZQdPTcepK7ecPhzKOYk4Er2YR4uHKme4qDeIh6N3XrLfpuM7vzRWQ==}
    cpu: [ppc64]
    os: [linux]

  '@rollup/rollup-linux-riscv64-gnu@4.31.0':
    resolution: {integrity: sha512-wal2Tc8O5lMBtoePLBYRKj2CImUCJ4UNGJlLwspx7QApYny7K1cUYlzQ/4IGQBLmm+y0RS7dwc3TDO/pmcneTw==}
    cpu: [riscv64]
    os: [linux]

  '@rollup/rollup-linux-s390x-gnu@4.31.0':
    resolution: {integrity: sha512-O1o5EUI0+RRMkK9wiTVpk2tyzXdXefHtRTIjBbmFREmNMy7pFeYXCFGbhKFwISA3UOExlo5GGUuuj3oMKdK6JQ==}
    cpu: [s390x]
    os: [linux]

  '@rollup/rollup-linux-x64-gnu@4.31.0':
    resolution: {integrity: sha512-zSoHl356vKnNxwOWnLd60ixHNPRBglxpv2g7q0Cd3Pmr561gf0HiAcUBRL3S1vPqRC17Zo2CX/9cPkqTIiai1g==}
    cpu: [x64]
    os: [linux]

  '@rollup/rollup-linux-x64-musl@4.31.0':
    resolution: {integrity: sha512-ypB/HMtcSGhKUQNiFwqgdclWNRrAYDH8iMYH4etw/ZlGwiTVxBz2tDrGRrPlfZu6QjXwtd+C3Zib5pFqID97ZA==}
    cpu: [x64]
    os: [linux]

  '@rollup/rollup-win32-arm64-msvc@4.31.0':
    resolution: {integrity: sha512-JuhN2xdI/m8Hr+aVO3vspO7OQfUFO6bKLIRTAy0U15vmWjnZDLrEgCZ2s6+scAYaQVpYSh9tZtRijApw9IXyMw==}
    cpu: [arm64]
    os: [win32]

  '@rollup/rollup-win32-ia32-msvc@4.31.0':
    resolution: {integrity: sha512-U1xZZXYkvdf5MIWmftU8wrM5PPXzyaY1nGCI4KI4BFfoZxHamsIe+BtnPLIvvPykvQWlVbqUXdLa4aJUuilwLQ==}
    cpu: [ia32]
    os: [win32]

  '@rollup/rollup-win32-x64-msvc@4.31.0':
    resolution: {integrity: sha512-ul8rnCsUumNln5YWwz0ted2ZHFhzhRRnkpBZ+YRuHoRAlUji9KChpOUOndY7uykrPEPXVbHLlsdo6v5yXo/TXw==}
    cpu: [x64]
    os: [win32]

  '@sindresorhus/is@4.6.0':
    resolution: {integrity: sha512-t09vSN3MdfsyCHoFcTRCH/iUtG7OJ0CsjzB8cjAmKc/va/kIgeDI/TxsigdncE/4be734m0cvIYwNaV4i2XqAw==}
    engines: {node: '>=10'}

  '@types/bun@1.1.18':
    resolution: {integrity: sha512-gtw6cIv/8Q530D0BmoYnjEzR65SjVq2SaUE0NeU6tbm7QBMsTZ61/NBNERtK/FUJaoi7PiteUohK7JcrXBCkvw==}

  '@types/estree@1.0.6':
    resolution: {integrity: sha512-AYnb1nQyY49te+VRAVgmzfcgjYS91mY5P0TKUDCLEM+gNnA+3T6rWITXRLYCpahpqSQbN5cE+gHpnPyXjHWxcw==}

  '@types/node@20.12.14':
    resolution: {integrity: sha512-scnD59RpYD91xngrQQLGkE+6UrHUPzeKZWhhjBSa3HSkwjbQc38+q3RoIVEwxQGRw3M+j5hpNAM+lgV3cVormg==}

  '@types/node@22.10.7':
    resolution: {integrity: sha512-V09KvXxFiutGp6B7XkpaDXlNadZxrzajcY50EuoLIpQ6WWYCSvf19lVIazzfIzQvhUN2HjX12spLojTnhuKlGg==}

  '@types/set-cookie-parser@2.4.10':
    resolution: {integrity: sha512-GGmQVGpQWUe5qglJozEjZV/5dyxbOOZ0LHe/lqyWssB88Y4svNfst0uqBVscdDeIKl5Jy5+aPSvy7mI9tYRguw==}

  '@types/ws@8.5.13':
    resolution: {integrity: sha512-osM/gWBTPKgHV8XkTunnegTRIsvF6owmf5w+JtAfOw472dptdm0dlGv4xCt6GwQRcC2XVOvvRE/0bAoQcL2QkA==}

  '@vitest/expect@3.0.3':
    resolution: {integrity: sha512-SbRCHU4qr91xguu+dH3RUdI5dC86zm8aZWydbp961aIR7G8OYNN6ZiayFuf9WAngRbFOfdrLHCGgXTj3GtoMRQ==}

  '@vitest/mocker@3.0.3':
    resolution: {integrity: sha512-XT2XBc4AN9UdaxJAeIlcSZ0ILi/GzmG5G8XSly4gaiqIvPV3HMTSIDZWJVX6QRJ0PX1m+W8Cy0K9ByXNb/bPIA==}
    peerDependencies:
      msw: ^2.4.9
      vite: ^5.0.0 || ^6.0.0
    peerDependenciesMeta:
      msw:
        optional: true
      vite:
        optional: true

  '@vitest/pretty-format@3.0.3':
    resolution: {integrity: sha512-gCrM9F7STYdsDoNjGgYXKPq4SkSxwwIU5nkaQvdUxiQ0EcNlez+PdKOVIsUJvh9P9IeIFmjn4IIREWblOBpP2Q==}

  '@vitest/runner@3.0.3':
    resolution: {integrity: sha512-Rgi2kOAk5ZxWZlwPguRJFOBmWs6uvvyAAR9k3MvjRvYrG7xYvKChZcmnnpJCS98311CBDMqsW9MzzRFsj2gX3g==}

  '@vitest/snapshot@3.0.3':
    resolution: {integrity: sha512-kNRcHlI4txBGztuJfPEJ68VezlPAXLRT1u5UCx219TU3kOG2DplNxhWLwDf2h6emwmTPogzLnGVwP6epDaJN6Q==}

  '@vitest/spy@3.0.3':
    resolution: {integrity: sha512-7/dgux8ZBbF7lEIKNnEqQlyRaER9nkAL9eTmdKJkDO3hS8p59ATGwKOCUDHcBLKr7h/oi/6hP+7djQk8049T2A==}

  '@vitest/utils@3.0.3':
    resolution: {integrity: sha512-f+s8CvyzPtMFY1eZKkIHGhPsQgYo5qCm6O8KZoim9qm1/jT64qBgGpO5tHscNH6BzRHM+edLNOP+3vO8+8pE/A==}

  acorn@8.14.0:
    resolution: {integrity: sha512-cl669nCJTZBsL97OF4kUQm5g5hC2uihk0NxY3WENAC0TYdILVkAyHymAntgxGkl7K+t0cXIrH5siy5S4XkFycA==}
    engines: {node: '>=0.4.0'}
    hasBin: true

  ansi-escapes@7.0.0:
    resolution: {integrity: sha512-GdYO7a61mR0fOlAsvC9/rIHf7L96sBc6dEWzeOu+KAea5bZyQRPIpojrVoI4AXGJS/ycu/fBTdLrUkA4ODrvjw==}
    engines: {node: '>=18'}

  ansi-regex@5.0.1:
    resolution: {integrity: sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==}
    engines: {node: '>=8'}

  ansi-regex@6.1.0:
    resolution: {integrity: sha512-7HSX4QQb4CspciLpVFwyRe79O3xsIZDDLER21kERQ71oaPodF8jL725AgJMFAYbooIqolJoRLuM81SpeUkpkvA==}
    engines: {node: '>=12'}

  ansi-styles@4.3.0:
    resolution: {integrity: sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==}
    engines: {node: '>=8'}

  ansi-styles@6.2.1:
    resolution: {integrity: sha512-bN798gFfQX+viw3R7yrGWRqnrN2oRkEkUjjl4JNn4E8GxxbjtG3FbrEIIY3l8/hrwUwIeCZvi4QuOTP4MErVug==}
    engines: {node: '>=12'}

  any-promise@1.3.0:
    resolution: {integrity: sha512-7UvmKalWRt1wgjL1RrGxoSJW/0QZFIegpeGvZG9kjp8vrRu55XTHbwnqq2GpXm9uLbcuhxm3IqX9OB4MZR1b2A==}

  argparse@2.0.1:
    resolution: {integrity: sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==}

  arktype@2.0.0:
    resolution: {integrity: sha512-LVuXndcKO+zB7Hg9laGJmXYD5BZYhm/cUFL5pgB/75/3sGnvN8fsQ/yuBlf4JSn90g4rOoU7+9aTvdn5lToWOg==}

  assertion-error@2.0.1:
    resolution: {integrity: sha512-Izi8RQcffqCeNVgFigKli1ssklIbpHnCYc6AknXGYoB6grJqyeby7jv12JUQgmTAnIDnbck1uxksT4dzN3PWBA==}
    engines: {node: '>=12'}

  balanced-match@1.0.2:
    resolution: {integrity: sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==}

  brace-expansion@2.0.1:
    resolution: {integrity: sha512-XnAIvQ8eM+kC6aULx6wuQiwVsnzsi9d3WxzV3FpWTGA19F621kwdbsAcFKXgKUHZWsy+mY6iL1sHTxWEFCytDA==}

  bumpp@9.10.1:
    resolution: {integrity: sha512-KG7oQmv6cz7QQwOvM3x/yPcF8+VBEtuLEEecmohNyb4+bLbtSVpJp8brjzcZYQN7UOyR4i0qIIYThnsBgP8uCA==}
    engines: {node: '>=10'}
    hasBin: true

  bun-types@1.1.44:
    resolution: {integrity: sha512-jtcekoZeSINgEcHSISzhR13w/cyE+Fankw2Cpl4c0fN3lRmKVAX0i9ay4FyK4lOxUK1HG4HkuIlrPvXKz4Y7sw==}

  bundle-require@5.1.0:
    resolution: {integrity: sha512-3WrrOuZiyaaZPWiEt4G3+IffISVC9HYlWueJEBWED4ZH4aIAC2PnkdnuRrR94M+w6yGWn4AglWtJtBI8YqvgoA==}
    engines: {node: ^12.20.0 || ^14.13.1 || >=16.0.0}
    peerDependencies:
      esbuild: '>=0.18'

  c12@2.0.1:
    resolution: {integrity: sha512-Z4JgsKXHG37C6PYUtIxCfLJZvo6FyhHJoClwwb9ftUkLpPSkuYqn6Tr+vnaN8hymm0kIbcg6Ey3kv/Q71k5w/A==}
    peerDependencies:
      magicast: ^0.3.5
    peerDependenciesMeta:
      magicast:
        optional: true

  cac@6.7.14:
    resolution: {integrity: sha512-b6Ilus+c3RrdDk+JhLKUAQfzzgLEPy6wcXqS7f/xe1EETvsDP6GORG7SFuOs6cID5YkqchW/LXZbX5bc8j7ZcQ==}
    engines: {node: '>=8'}

  chai@5.1.2:
    resolution: {integrity: sha512-aGtmf24DW6MLHHG5gCx4zaI3uBq3KRtxeVs0DjFH6Z0rDNbsvTxFASFvdj79pxjxZ8/5u3PIiN3IwEIQkiiuPw==}
    engines: {node: '>=12'}

  chalk@4.1.2:
    resolution: {integrity: sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==}
    engines: {node: '>=10'}

  chalk@5.4.1:
    resolution: {integrity: sha512-zgVZuo2WcZgfUEmsn6eO3kINexW8RAE4maiQ8QNs8CtpPCSyMiYsULR3HQYkm3w8FIA3SberyMJMSldGsW+U3w==}
    engines: {node: ^12.17.0 || ^14.13 || >=16.0.0}

  char-regex@1.0.2:
    resolution: {integrity: sha512-kWWXztvZ5SBQV+eRgKFeh8q5sLuZY2+8WUIzlxWVTg+oGwY14qylx1KbKzHd8P6ZYkAg0xyIDU9JMHhyJMZ1jw==}
    engines: {node: '>=10'}

  check-error@2.1.1:
    resolution: {integrity: sha512-OAlb+T7V4Op9OwdkjmguYRqncdlx5JiofwOAUkmTF+jNdHwzTaTs4sRAGpzLF3oOz5xAyDGrPgeIDFQmDOTiJw==}
    engines: {node: '>= 16'}

  chokidar@4.0.3:
    resolution: {integrity: sha512-Qgzu8kfBvo+cA4962jnP1KkS6Dop5NS6g7R5LFYJr4b8Ub94PPQXUksCw9PvXoeXPRRddRNC5C1JQUR2SMGtnA==}
    engines: {node: '>= 14.16.0'}

  chownr@2.0.0:
    resolution: {integrity: sha512-bIomtDF5KGpdogkLd9VspvFzk9KfpyyGlS8YFVZl7TGPBHL5snIOnxeshwVgPteQ9b4Eydl+pVbIyE1DcvCWgQ==}
    engines: {node: '>=10'}

  citty@0.1.6:
    resolution: {integrity: sha512-tskPPKEs8D2KPafUypv2gxwJP8h/OaJmC82QQGGDQcHvXX43xF2VDACcJVmZ0EuSxkpO9Kc4MlrA3q0+FG58AQ==}

  cjs-module-lexer@1.4.1:
    resolution: {integrity: sha512-cuSVIHi9/9E/+821Qjdvngor+xpnlwnuwIyZOaLmHBVdXL+gP+I6QQB9VkO7RI77YIcTV+S1W9AreJ5eN63JBA==}

  cli-highlight@2.1.11:
    resolution: {integrity: sha512-9KDcoEVwyUXrjcJNvHD0NFc/hiwe/WPVYIleQh2O1N2Zro5gWJZ/K+3DGn8w8P/F6FxOgzyC5bxDyHIgCSPhGg==}
    engines: {node: '>=8.0.0', npm: '>=5.0.0'}
    hasBin: true

  cli-table3@0.6.5:
    resolution: {integrity: sha512-+W/5efTR7y5HRD7gACw9yQjqMVvEMLBHmboM/kPWam+H+Hmyrgjh6YncVKK122YZkXrLudzTuAukUw9FnMf7IQ==}
    engines: {node: 10.* || >= 12.*}

  cliui@7.0.4:
    resolution: {integrity: sha512-OcRE68cOsVMXp1Yvonl/fzkQOyjLSu/8bhPDfQt0e0/Eb283TKP20Fs2MqoPsr9SwA595rRCA+QMzYc9nBP+JQ==}

  color-convert@2.0.1:
    resolution: {integrity: sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==}
    engines: {node: '>=7.0.0'}

  color-name@1.1.4:
    resolution: {integrity: sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==}

  commander@10.0.1:
    resolution: {integrity: sha512-y4Mg2tXshplEbSGzx7amzPwKKOCGuoSRP/CjEdwwk0FOGlUbq6lKuoyDZTNZkmxHdJtp54hdfY/JUrdL7Xfdug==}
    engines: {node: '>=14'}

  commander@4.1.1:
    resolution: {integrity: sha512-NOKm8xhkzAjzFx8B2v5OAHT+u5pRQc2UCa2Vq9jYL/31o2wi9mxBA7LIFs3sV5VSC49z6pEhfbMULvShKj26WA==}
    engines: {node: '>= 6'}

  confbox@0.1.8:
    resolution: {integrity: sha512-RMtmw0iFkeR4YV+fUOSucriAQNb9g8zFR52MWCtl+cCZOFRNL6zeB395vPzFhEjjn4fMxXudmELnl/KF/WrK6w==}

  consola@3.4.0:
    resolution: {integrity: sha512-EiPU8G6dQG0GFHNR8ljnZFki/8a+cQwEQ+7wpxdChl02Q8HXlwEZWD5lqAF8vC2sEC3Tehr8hy7vErz88LHyUA==}
    engines: {node: ^14.18.0 || >=16.10.0}

  cross-spawn@7.0.6:
    resolution: {integrity: sha512-uV2QOWP2nWzsy2aMp8aRibhi9dlzF5Hgh5SHaB9OiTGEyDTiJJyx0uy51QXdyWbtAHNua4XJzUKca3OzKUd3vA==}
    engines: {node: '>= 8'}

  debug@4.4.0:
    resolution: {integrity: sha512-6WTZ/IxCY/T6BALoZHaE4ctp9xm+Z5kY/pzYaCHRFeyVhojxlrm+46y68HA6hr0TcwEssoxNiDEUJQjfPZ/RYA==}
    engines: {node: '>=6.0'}
    peerDependencies:
      supports-color: '*'
    peerDependenciesMeta:
      supports-color:
        optional: true

  deep-eql@5.0.2:
    resolution: {integrity: sha512-h5k/5U50IJJFpzfL6nO9jaaumfjO/f2NjK/oYB2Djzm4p9L+3T9qWpZqZ2hAbLPuuYq9wrU08WQyBTL5GbPk5Q==}
    engines: {node: '>=6'}

  defu@6.1.4:
    resolution: {integrity: sha512-mEQCMmwJu317oSz8CwdIOdwf3xMif1ttiM8LTufzc3g6kR+9Pe236twL8j3IYT1F7GfRgGcW6MWxzZjLIkuHIg==}

  destr@2.0.3:
    resolution: {integrity: sha512-2N3BOUU4gYMpTP24s5rF5iP7BDr7uNTCs4ozw3kf/eKfvWSIu93GEBi5m427YoyJoeOzQ5smuu4nNAPGb8idSQ==}

  dotenv@16.4.7:
    resolution: {integrity: sha512-47qPchRCykZC03FhkYAhrvwU4xDBFIj1QPqaarj6mdM/hgUzfPHcpkHJOn3mJAufFeeAxAzeGsr5X0M4k6fLZQ==}
    engines: {node: '>=12'}

  eastasianwidth@0.2.0:
    resolution: {integrity: sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==}

  emoji-regex@8.0.0:
    resolution: {integrity: sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==}

  emoji-regex@9.2.2:
    resolution: {integrity: sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==}

  emojilib@2.4.0:
    resolution: {integrity: sha512-5U0rVMU5Y2n2+ykNLQqMoqklN9ICBT/KsvC1Gz6vqHbz2AXXGkG+Pm5rMWk/8Vjrr/mY9985Hi8DYzn1F09Nyw==}

  environment@1.1.0:
    resolution: {integrity: sha512-xUtoPkMggbz0MPyPiIWr1Kp4aeWJjDZ6SMvURhimjdZgsRuDplF5/s9hcgGhyXMhs+6vpnuoiZ2kFiu3FMnS8Q==}
    engines: {node: '>=18'}

  es-module-lexer@1.6.0:
    resolution: {integrity: sha512-qqnD1yMU6tk/jnaMosogGySTZP8YtUgAffA9nMN+E/rjxcfRQ6IEk7IiozUjgxKoFHBGjTLnrHB/YC45r/59EQ==}

  esbuild@0.21.5:
    resolution: {integrity: sha512-mg3OPMV4hXywwpoDxu3Qda5xCKQi+vCTZq8S9J/EpkhB2HzKXq4SNFZE3+NK93JYxc8VMSep+lOUSC/RVKaBqw==}
    engines: {node: '>=12'}
    hasBin: true

  esbuild@0.24.2:
    resolution: {integrity: sha512-+9egpBW8I3CD5XPe0n6BfT5fxLzxrlDzqydF3aviG+9ni1lDC/OvMHcxqEFV0+LANZG5R1bFMWfUrjVsdwxJvA==}
    engines: {node: '>=18'}
    hasBin: true

  escalade@3.2.0:
    resolution: {integrity: sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA==}
    engines: {node: '>=6'}

  estree-walker@3.0.3:
    resolution: {integrity: sha512-7RUKfXgSMMkzt6ZuXmqapOurLGPPfgj6l9uRZ7lRGolvk0y2yocc35LdcxKC5PQZdn2DMqioAQ2NoWcrTKmm6g==}

  execa@8.0.1:
    resolution: {integrity: sha512-VyhnebXciFV2DESc+p6B+y0LjSm0krU4OgJN44qFAhBY0TJ+1V61tYD2+wHusZ6F9n5K+vl8k0sTy7PEfV4qpg==}
    engines: {node: '>=16.17'}

  expect-type@1.1.0:
    resolution: {integrity: sha512-bFi65yM+xZgk+u/KRIpekdSYkTB5W1pEf0Lt8Q8Msh7b+eQ7LXVtIB1Bkm4fvclDEL1b2CZkMhv2mOeF8tMdkA==}
    engines: {node: '>=12.0.0'}

  fdir@6.4.3:
    resolution: {integrity: sha512-PMXmW2y1hDDfTSRc9gaXIuCCRpuoz3Kaz8cUelp3smouvfT632ozg2vrT6lJsHKKOF59YLbOGfAWGUcKEfRMQw==}
    peerDependencies:
      picomatch: ^3 || ^4
    peerDependenciesMeta:
      picomatch:
        optional: true

  fflate@0.8.2:
    resolution: {integrity: sha512-cPJU47OaAoCbg0pBvzsgpTPhmhqI5eJjh/JIu8tPj5q+T7iLvW/JAYUqmE7KOB4R1ZyEhzBaIQpQpardBF5z8A==}

  foreground-child@3.3.0:
    resolution: {integrity: sha512-Ld2g8rrAyMYFXBhEqMz8ZAHBi4J4uS1i/CxGMDnjyFWddMXLVcDp051DZfu+t7+ab7Wv6SMqpWmyFIj5UbfFvg==}
    engines: {node: '>=14'}

  fs-minipass@2.1.0:
    resolution: {integrity: sha512-V/JgOLFCS+R6Vcq0slCuaeWEdNC3ouDlJMNIsacH2VtALiu9mV4LPrHc5cDl8k5aw6J8jwgWWpiTo5RYhmIzvg==}
    engines: {node: '>= 8'}

  fsevents@2.3.3:
    resolution: {integrity: sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==}
    engines: {node: ^8.16.0 || ^10.6.0 || >=11.0.0}
    os: [darwin]

  get-caller-file@2.0.5:
    resolution: {integrity: sha512-DyFP3BM/3YHTQOCUL/w0OZHR0lpKeGrxotcHWcqNEdnltqFwXVfhEBQ94eIo34AfQpo0rGki4cyIiftY06h2Fg==}
    engines: {node: 6.* || 8.* || >= 10.*}

  get-stream@8.0.1:
    resolution: {integrity: sha512-VaUJspBffn/LMCJVoMvSAdmscJyS1auj5Zulnn5UoYcY531UWmdwhRWkcGKnGU93m5HSXP9LP2usOryrBtQowA==}
    engines: {node: '>=16'}

  giget@1.2.3:
    resolution: {integrity: sha512-8EHPljDvs7qKykr6uw8b+lqLiUc/vUg+KVTI0uND4s63TdsZM2Xus3mflvF0DDG9SiM4RlCkFGL+7aAjRmV7KA==}
    hasBin: true

  glob@10.4.5:
    resolution: {integrity: sha512-7Bv8RF0k6xjo7d4A/PxYLbUCfb6c+Vpd2/mB2yRDlew7Jb5hEXiCD9ibfO7wpk8i4sevK6DFny9h7EYbM3/sHg==}
    hasBin: true

  has-flag@4.0.0:
    resolution: {integrity: sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==}
    engines: {node: '>=8'}

  highlight.js@10.7.3:
    resolution: {integrity: sha512-tzcUFauisWKNHaRkN4Wjl/ZA07gENAjFl3J/c480dprkGTg5EQstgaNFqBfUqCq54kZRIEcreTsAgF/m2quD7A==}

  human-signals@5.0.0:
    resolution: {integrity: sha512-AXcZb6vzzrFAUE61HnN4mpLqd/cSIwNQjtNWR0euPm6y0iqx3G4gOXaIDdtdDwZmhwe82LA6+zinmW4UBWVePQ==}
    engines: {node: '>=16.17.0'}

  is-fullwidth-code-point@3.0.0:
    resolution: {integrity: sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==}
    engines: {node: '>=8'}

  is-stream@3.0.0:
    resolution: {integrity: sha512-LnQR4bZ9IADDRSkvpqMGvt/tEJWclzklNgSw48V5EAaAeDd6qGvN8ei6k5p0tvxSR171VmGyHuTiAOfxAbr8kA==}
    engines: {node: ^12.20.0 || ^14.13.1 || >=16.0.0}

  isexe@2.0.0:
    resolution: {integrity: sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==}

  jackspeak@3.4.3:
    resolution: {integrity: sha512-OGlZQpz2yfahA/Rd1Y8Cd9SIEsqvXkLVoSw/cgwhnhFMDbsQFeZYoJJ7bIZBS9BcamUW96asq/npPWugM+RQBw==}

  jiti@2.4.2:
    resolution: {integrity: sha512-rg9zJN+G4n2nfJl5MW3BMygZX56zKPNVEYYqq7adpmMh4Jn2QNEwhvQlFy6jPVdcod7txZtKHWnyZiA3a0zP7A==}
    hasBin: true

  joycon@3.1.1:
    resolution: {integrity: sha512-34wB/Y7MW7bzjKRjUKTa46I2Z7eV62Rkhva+KkopW7Qvv/OSWBqvkSY7vusOPrNuZcUG3tApvdVgNB8POj3SPw==}
    engines: {node: '>=10'}

  js-yaml@4.1.0:
    resolution: {integrity: sha512-wpxZs9NoxZaJESJGIZTyDEaYpl0FKSA+FB9aJiyemKhMwkxQg63h4T1KJgUGHpTqPDNRcmmYLugrRjJlBtWvRA==}
    hasBin: true

  jsonc-parser@3.3.1:
    resolution: {integrity: sha512-HUgH65KyejrUFPvHFPbqOY0rsFip3Bo5wb4ngvdi1EpCYWUQDC5V+Y7mZws+DLkr4M//zQJoanu1SP+87Dv1oQ==}

  kleur@3.0.3:
    resolution: {integrity: sha512-eTIzlVOSUR+JxdDFepEYcBMtZ9Qqdef+rnzWdRZuMbOywu5tO2w2N7rqjoANZ5k9vywhL6Br1VRjUIgTQx4E8w==}
    engines: {node: '>=6'}

  lilconfig@3.1.3:
    resolution: {integrity: sha512-/vlFKAoH5Cgt3Ie+JLhRbwOsCQePABiU3tJ1egGvyQ+33R/vcwM2Zl2QR/LzjsBeItPt3oSVXapn+m4nQDvpzw==}
    engines: {node: '>=14'}

  lines-and-columns@1.2.4:
    resolution: {integrity: sha512-7ylylesZQ/PV29jhEDl3Ufjo6ZX7gCqJr5F7PKrqc93v7fzSymt1BpwEU8nAUXs8qzzvqhbjhK5QZg6Mt/HkBg==}

  load-tsconfig@0.2.5:
    resolution: {integrity: sha512-IXO6OCs9yg8tMKzfPZ1YmheJbZCiEsnBdcB03l0OcfK9prKnJb96siuHCr5Fl37/yo9DnKU+TLpxzTUspw9shg==}
    engines: {node: ^12.20.0 || ^14.13.1 || >=16.0.0}

  lodash.sortby@4.7.0:
    resolution: {integrity: sha512-HDWXG8isMntAyRF5vZ7xKuEvOhT4AhlRt/3czTSjvGUxjYCBVRQY48ViDHyfYz9VIoBkW4TMGQNapx+l3RUwdA==}

  loupe@3.1.2:
    resolution: {integrity: sha512-23I4pFZHmAemUnz8WZXbYRSKYj801VDaNv9ETuMh7IrMc7VuVVSo+Z9iLE3ni30+U48iDWfi30d3twAXBYmnCg==}

  lru-cache@10.4.3:
    resolution: {integrity: sha512-JNAzZcXrCt42VGLuYz0zfAzDfAvJWW6AfYlDBQyDV5DClI2m5sAmK+OIO7s59XfsRsWHp02jAJrRadPRGTt6SQ==}

  magic-string@0.30.17:
    resolution: {integrity: sha512-sNPKHvyjVf7gyjwS4xGTaW/mCnF8wnjtifKBEhxfZ7E/S8tQ0rssrwGNn6q8JH/ohItJfSQp9mBtQYuTlH5QnA==}

  marked-terminal@7.2.1:
    resolution: {integrity: sha512-rQ1MoMFXZICWNsKMiiHwP/Z+92PLKskTPXj+e7uwXmuMPkNn7iTqC+IvDekVm1MPeC9wYQeLxeFaOvudRR/XbQ==}
    engines: {node: '>=16.0.0'}
    peerDependencies:
      marked: '>=1 <15'

  marked@9.1.6:
    resolution: {integrity: sha512-jcByLnIFkd5gSXZmjNvS1TlmRhCXZjIzHYlaGkPlLIekG55JDR2Z4va9tZwCiP+/RDERiNhMOFu01xd6O5ct1Q==}
    engines: {node: '>= 16'}
    hasBin: true

  merge-stream@2.0.0:
    resolution: {integrity: sha512-abv/qOcuPfk3URPfDzmZU1LKmuw8kT+0nIHvKrKgFrwifol/doWcdA4ZqsWQ8ENrFKkd67Mfpo/LovbIUsbt3w==}

  mimic-fn@4.0.0:
    resolution: {integrity: sha512-vqiC06CuhBTUdZH+RYl8sFrL096vA45Ok5ISO6sE/Mr1jRbGH4Csnhi8f3wKVl7x8mO4Au7Ir9D3Oyv1VYMFJw==}
    engines: {node: '>=12'}

  minimatch@9.0.5:
    resolution: {integrity: sha512-G6T0ZX48xgozx7587koeX9Ys2NYy6Gmv//P89sEte9V9whIapMNF4idKxnW2QtCcLiTWlb/wfCabAtAFWhhBow==}
    engines: {node: '>=16 || 14 >=14.17'}

  minipass@3.3.6:
    resolution: {integrity: sha512-DxiNidxSEK+tHG6zOIklvNOwm3hvCrbUrdtzY74U6HKTJxvIDfOUL5W5P2Ghd3DTkhhKPYGqeNUIh5qcM4YBfw==}
    engines: {node: '>=8'}

  minipass@5.0.0:
    resolution: {integrity: sha512-3FnjYuehv9k6ovOEbyOswadCDPX1piCfhV8ncmYtHOjuPwylVWsghTLo7rabjC3Rx5xD4HDx8Wm1xnMF7S5qFQ==}
    engines: {node: '>=8'}

  minipass@7.1.2:
    resolution: {integrity: sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==}
    engines: {node: '>=16 || 14 >=14.17'}

  minizlib@2.1.2:
    resolution: {integrity: sha512-bAxsR8BVfj60DWXHE3u30oHzfl4G7khkSuPW+qvpd7jFRHm7dLxOjUk1EHACJ/hxLY8phGJ0YhYHZo7jil7Qdg==}
    engines: {node: '>= 8'}

  mkdirp@1.0.4:
    resolution: {integrity: sha512-vVqVZQyf3WLx2Shd0qJ9xuvqgAyKPLAiqITEtqW0oIUjzo3PePDd6fW9iFz30ef7Ysp/oiWqbhszeGWW2T6Gzw==}
    engines: {node: '>=10'}
    hasBin: true

  mlly@1.7.4:
    resolution: {integrity: sha512-qmdSIPC4bDJXgZTCR7XosJiNKySV7O215tsPtDN9iEO/7q/76b/ijtgRu/+epFXSJhijtTCCGp3DWS549P3xKw==}

  ms@2.1.3:
    resolution: {integrity: sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==}

  mz@2.7.0:
    resolution: {integrity: sha512-z81GNO7nnYMEhrGh9LeymoE4+Yr0Wn5McHIZMK5cfQCl+NDX08sCZgUc9/6MHni9IWuFLm1Z3HTCXu2z9fN62Q==}

  nanoid@3.3.8:
    resolution: {integrity: sha512-WNLf5Sd8oZxOm+TzppcYk8gVOgP+l58xNy58D0nbUnOxOWRWvlcCV4kUF7ltmI6PsrLl/BgKEyS4mqsGChFN0w==}
    engines: {node: ^10 || ^12 || ^13.7 || ^14 || >=15.0.1}
    hasBin: true

  node-emoji@2.2.0:
    resolution: {integrity: sha512-Z3lTE9pLaJF47NyMhd4ww1yFTAP8YhYI8SleJiHzM46Fgpm5cnNzSl9XfzFNqbaz+VlJrIj3fXQ4DeN1Rjm6cw==}
    engines: {node: '>=18'}

  node-fetch-native@1.6.6:
    resolution: {integrity: sha512-8Mc2HhqPdlIfedsuZoc3yioPuzp6b+L5jRCRY1QzuWZh2EGJVQrGppC6V6cF0bLdbW0+O2YpqCA25aF/1lvipQ==}

  npm-run-path@5.3.0:
    resolution: {integrity: sha512-ppwTtiJZq0O/ai0z7yfudtBpWIoxM8yE6nHi1X47eFR2EWORqfbu6CnPlNsjeN683eT0qG6H/Pyf9fCcvjnnnQ==}
    engines: {node: ^12.20.0 || ^14.13.1 || >=16.0.0}

  nypm@0.3.12:
    resolution: {integrity: sha512-D3pzNDWIvgA+7IORhD/IuWzEk4uXv6GsgOxiid4UU3h9oq5IqV1KtPDi63n4sZJ/xcWlr88c0QM2RgN5VbOhFA==}
    engines: {node: ^14.16.0 || >=16.10.0}
    hasBin: true

  object-assign@4.1.1:
    resolution: {integrity: sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==}
    engines: {node: '>=0.10.0'}

  ohash@1.1.4:
    resolution: {integrity: sha512-FlDryZAahJmEF3VR3w1KogSEdWX3WhA5GPakFx4J81kEAiHyLMpdLLElS8n8dfNadMgAne/MywcvmogzscVt4g==}

  onetime@6.0.0:
    resolution: {integrity: sha512-1FlR+gjXK7X+AsAHso35MnyN5KqGwJRi/31ft6x0M194ht7S+rWAvd7PHss9xSKMzE0asv1pyIHaJYq+BbacAQ==}
    engines: {node: '>=12'}

  package-json-from-dist@1.0.1:
    resolution: {integrity: sha512-UEZIS3/by4OC8vL3P2dTXRETpebLI2NiI5vIrjaD/5UtrkFX/tNbwjTSRAGC/+7CAo2pIcBaRgWmcBBHcsaCIw==}

  package-manager-detector@0.2.8:
    resolution: {integrity: sha512-ts9KSdroZisdvKMWVAVCXiKqnqNfXz4+IbrBG8/BWx/TR5le+jfenvoBuIZ6UWM9nz47W7AbD9qYfAwfWMIwzA==}

  parse5-htmlparser2-tree-adapter@6.0.1:
    resolution: {integrity: sha512-qPuWvbLgvDGilKc5BoicRovlT4MtYT6JfJyBOMDsKoiT+GiuP5qyrPCnR9HcPECIJJmZh5jRndyNThnhhb/vlA==}

  parse5@5.1.1:
    resolution: {integrity: sha512-ugq4DFI0Ptb+WWjAdOK16+u/nHfiIrcE+sh8kZMaM0WllQKLI9rOUq6c2b7cwPkXdzfQESqvoqK6ug7U/Yyzug==}

  parse5@6.0.1:
    resolution: {integrity: sha512-Ofn/CTFzRGTTxwpNEs9PP93gXShHcTq255nzRYSKe8AkVpZY7e1fpmTfOyoIvjP5HG7Z2ZM7VS9PPhQGW2pOpw==}

  path-key@3.1.1:
    resolution: {integrity: sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==}
    engines: {node: '>=8'}

  path-key@4.0.0:
    resolution: {integrity: sha512-haREypq7xkM7ErfgIyA0z+Bj4AGKlMSdlQE2jvJo6huWD1EdkKYV+G/T4nq0YEF2vgTT8kqMFKo1uHn950r4SQ==}
    engines: {node: '>=12'}

  path-scurry@1.11.1:
    resolution: {integrity: sha512-Xa4Nw17FS9ApQFJ9umLiJS4orGjm7ZzwUrwamcGQuHSzDyth9boKDaycYdDcZDuqYATXw4HFXgaqWTctW/v1HA==}
    engines: {node: '>=16 || 14 >=14.18'}

  pathe@1.1.2:
    resolution: {integrity: sha512-whLdWMYL2TwI08hn8/ZqAbrVemu0LNaNNJZX73O6qaIdCTfXutsLhMkjdENX0qhsQ9uIimo4/aQOmXkoon2nDQ==}

  pathe@2.0.2:
    resolution: {integrity: sha512-15Ztpk+nov8DR524R4BF7uEuzESgzUEAV4Ah7CUMNGXdE5ELuvxElxGXndBl32vMSsWa1jpNf22Z+Er3sKwq+w==}

  pathval@2.0.0:
    resolution: {integrity: sha512-vE7JKRyES09KiunauX7nd2Q9/L7lhok4smP9RZTDeD4MVs72Dp2qNFVz39Nz5a0FVEW0BJR6C0DYrq6unoziZA==}
    engines: {node: '>= 14.16'}

  perfect-debounce@1.0.0:
    resolution: {integrity: sha512-xCy9V055GLEqoFaHoC1SoLIaLmWctgCUaBaWxDZ7/Zx4CTyX7cJQLJOok/orfjZAh9kEYpjJa4d0KcJmCbctZA==}

  picocolors@1.1.1:
    resolution: {integrity: sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==}

  picomatch@4.0.2:
    resolution: {integrity: sha512-M7BAV6Rlcy5u+m6oPhAPFgJTzAioX/6B0DxyvDlo9l8+T3nLKbrczg2WLUyzd45L8RqfUMyGPzekbMvX2Ldkwg==}
    engines: {node: '>=12'}

  pirates@4.0.6:
    resolution: {integrity: sha512-saLsH7WeYYPiD25LDuLRRY/i+6HaPYr6G1OUlN39otzkSTxKnubR9RTxS3/Kk50s1g2JTgFwWQDQyplC5/SHZg==}
    engines: {node: '>= 6'}

  pkg-types@1.3.1:
    resolution: {integrity: sha512-/Jm5M4RvtBFVkKWRu2BLUTNP8/M2a+UwuAX+ae4770q1qVGtfjG+WTCupoZixokjmHiry8uI+dlY8KXYV5HVVQ==}

  postcss-load-config@6.0.1:
    resolution: {integrity: sha512-oPtTM4oerL+UXmx+93ytZVN82RrlY/wPUV8IeDxFrzIjXOLF1pN+EmKPLbubvKHT2HC20xXsCAH2Z+CKV6Oz/g==}
    engines: {node: '>= 18'}
    peerDependencies:
      jiti: '>=1.21.0'
      postcss: '>=8.0.9'
      tsx: ^4.8.1
      yaml: ^2.4.2
    peerDependenciesMeta:
      jiti:
        optional: true
      postcss:
        optional: true
      tsx:
        optional: true
      yaml:
        optional: true

  postcss@8.5.1:
    resolution: {integrity: sha512-6oz2beyjc5VMn/KV1pPw8fliQkhBXrVn1Z3TVyqZxU8kZpzEKhBdmCFqI6ZbmGtamQvQGuU1sgPTk8ZrXDD7jQ==}
    engines: {node: ^10 || ^12 || >=14}

  prompts@2.4.2:
    resolution: {integrity: sha512-NxNv/kLguCA7p3jE8oL2aEBsrJWgAakBpgmgK6lpPWV+WuOmY6r2/zbAVnP+T8bQlA0nzHXSJSJW0Hq7ylaD2Q==}
    engines: {node: '>= 6'}

  punycode@2.3.1:
    resolution: {integrity: sha512-vYt7UD1U9Wg6138shLtLOvdAu+8DsC/ilFtEVHcH+wydcSpNE20AfSOduf6MkRFahL5FY7X1oU7nKVZFtfq8Fg==}
    engines: {node: '>=6'}

  rc9@2.1.2:
    resolution: {integrity: sha512-btXCnMmRIBINM2LDZoEmOogIZU7Qe7zn4BpomSKZ/ykbLObuBdvG+mFq11DL6fjH1DRwHhrlgtYWG96bJiC7Cg==}

  readdirp@4.1.1:
    resolution: {integrity: sha512-h80JrZu/MHUZCyHu5ciuoI0+WxsCxzxJTILn6Fs8rxSnFPh+UVHYfeIxK1nVGugMqkfC4vJcBOYbkfkwYK0+gw==}
    engines: {node: '>= 14.18.0'}

  require-directory@2.1.1:
    resolution: {integrity: sha512-fGxEI7+wsG9xrvdjsrlmL22OMTTiHRwAMroiEeMgq8gzoLC/PQr7RsRDSTLUg/bZAZtF+TVIkHc6/4RIKrui+Q==}
    engines: {node: '>=0.10.0'}

  resolve-from@5.0.0:
    resolution: {integrity: sha512-qYg9KP24dD5qka9J47d0aVky0N+b4fTU89LN9iDnjB5waksiC49rvMB0PrUJQGoTmH50XPiqOvAjDfaijGxYZw==}
    engines: {node: '>=8'}

  rollup@4.31.0:
    resolution: {integrity: sha512-9cCE8P4rZLx9+PjoyqHLs31V9a9Vpvfo4qNcs6JCiGWYhw2gijSetFbH6SSy1whnkgcefnUwr8sad7tgqsGvnw==}
    engines: {node: '>=18.0.0', npm: '>=8.0.0'}
    hasBin: true

  rou3@0.5.1:
    resolution: {integrity: sha512-OXMmJ3zRk2xeXFGfA3K+EOPHC5u7RDFG7lIOx0X1pdnhUkI8MdVrbV+sNsD80ElpUZ+MRHdyxPnFthq9VHs8uQ==}

  semver@7.6.3:
    resolution: {integrity: sha512-oVekP1cKtI+CTDvHWYFUcMtsK/00wmAEfyqKfNdARm8u1wNVhSgaX7A8d4UuIlUI5e84iEwOhs7ZPYRmzU9U6A==}
    engines: {node: '>=10'}
    hasBin: true

  set-cookie-parser@2.7.1:
    resolution: {integrity: sha512-IOc8uWeOZgnb3ptbCURJWNjWUPcO3ZnTTdzsurqERrP6nPyv+paC55vJM0LpOlT2ne+Ix+9+CRG1MNLlyZ4GjQ==}

  shebang-command@2.0.0:
    resolution: {integrity: sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==}
    engines: {node: '>=8'}

  shebang-regex@3.0.0:
    resolution: {integrity: sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==}
    engines: {node: '>=8'}

  siginfo@2.0.0:
    resolution: {integrity: sha512-ybx0WO1/8bSBLEWXZvEd7gMW3Sn3JFlW3TvX1nREbDLRNQNaeNN8WK0meBwPdAaOI7TtRRRJn/Es1zhrrCHu7g==}

  signal-exit@4.1.0:
    resolution: {integrity: sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==}
    engines: {node: '>=14'}

  sisteransi@1.0.5:
    resolution: {integrity: sha512-bLGGlR1QxBcynn2d5YmDX4MGjlZvy2MRBDRNHLJ8VI6l6+9FUiyTFNJ0IveOSP0bcXgVDPRcfGqA0pjaqUpfVg==}

  skin-tone@2.0.0:
    resolution: {integrity: sha512-kUMbT1oBJCpgrnKoSr0o6wPtvRWT9W9UKvGLwfJYO2WuahZRHOpEyL1ckyMGgMWh0UdpmaoFqKKD29WTomNEGA==}
    engines: {node: '>=8'}

  source-map-js@1.2.1:
    resolution: {integrity: sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==}
    engines: {node: '>=0.10.0'}

  source-map@0.8.0-beta.0:
    resolution: {integrity: sha512-2ymg6oRBpebeZi9UUNsgQ89bhx01TcTkmNTGnNO88imTmbSgy4nfujrgVEFKWpMTEGA11EDkTt7mqObTPdigIA==}
    engines: {node: '>= 8'}

  stackback@0.0.2:
    resolution: {integrity: sha512-1XMJE5fQo1jGH6Y/7ebnwPOBEkIEnT4QF32d5R1+VXdXveM0IBMJt8zfaxX1P3QhVwrYe+576+jkANtSS2mBbw==}

  std-env@3.8.0:
    resolution: {integrity: sha512-Bc3YwwCB+OzldMxOXJIIvC6cPRWr/LxOp48CdQTOkPyk/t4JWWJbrilwBd7RJzKV8QW7tJkcgAmeuLLJugl5/w==}

  string-width@4.2.3:
    resolution: {integrity: sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==}
    engines: {node: '>=8'}

  string-width@5.1.2:
    resolution: {integrity: sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==}
    engines: {node: '>=12'}

  strip-ansi@6.0.1:
    resolution: {integrity: sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==}
    engines: {node: '>=8'}

  strip-ansi@7.1.0:
    resolution: {integrity: sha512-iq6eVVI64nQQTRYq2KtEg2d2uU7LElhTJwsH4YzIHZshxlgZms/wIc4VoDQTlG/IvVIrBKG06CrZnp0qv7hkcQ==}
    engines: {node: '>=12'}

  strip-final-newline@3.0.0:
    resolution: {integrity: sha512-dOESqjYr96iWYylGObzd39EuNTa5VJxyvVAEm5Jnh7KGo75V43Hk1odPQkNDyXNmUR6k+gEiDVXnjB8HJ3crXw==}
    engines: {node: '>=12'}

  sucrase@3.35.0:
    resolution: {integrity: sha512-8EbVDiu9iN/nESwxeSxDKe0dunta1GOlHufmSSXxMD2z2/tMZpDMpvXQGsc+ajGo8y2uYUmixaSRUc/QPoQ0GA==}
    engines: {node: '>=16 || 14 >=14.17'}
    hasBin: true

  supports-color@7.2.0:
    resolution: {integrity: sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==}
    engines: {node: '>=8'}

  supports-hyperlinks@3.1.0:
    resolution: {integrity: sha512-2rn0BZ+/f7puLOHZm1HOJfwBggfaHXUpPUSSG/SWM4TWp5KCfmNYwnC3hruy2rZlMnmWZ+QAGpZfchu3f3695A==}
    engines: {node: '>=14.18'}

  tar@6.2.1:
    resolution: {integrity: sha512-DZ4yORTwrbTj/7MZYq2w+/ZFdI6OZ/f9SFHR+71gIVUZhOQPHzVCLpvRnPgyaMpfWxxk/4ONva3GQSyNIKRv6A==}
    engines: {node: '>=10'}

  thenify-all@1.6.0:
    resolution: {integrity: sha512-RNxQH/qI8/t3thXJDwcstUO4zeqo64+Uy/+sNVRBx4Xn2OX+OZ9oP+iJnNFqplFra2ZUVeKCSa2oVWi3T4uVmA==}
    engines: {node: '>=0.8'}

  thenify@3.3.1:
    resolution: {integrity: sha512-RVZSIV5IG10Hk3enotrhvz0T9em6cyHBLkH/YAZuKqd8hRkKhSfCGIcP2KUY0EPxndzANBmNllzWPwak+bheSw==}

  tinybench@2.9.0:
    resolution: {integrity: sha512-0+DUvqWMValLmha6lr4kD8iAMK1HzV0/aKnCtWb9v9641TnP/MFb7Pc2bxoxQjTXAErryXVgUOfv2YqNllqGeg==}

  tinyexec@0.3.2:
    resolution: {integrity: sha512-KQQR9yN7R5+OSwaK0XQoj22pwHoTlgYqmUscPYoknOoWCWfj/5/ABTMRi69FrKU5ffPVh5QcFikpWJI/P1ocHA==}

  tinyglobby@0.2.10:
    resolution: {integrity: sha512-Zc+8eJlFMvgatPZTl6A9L/yht8QqdmUNtURHaKZLmKBE12hNPSrqNkUp2cs3M/UKmNVVAMFQYSjYIVHDjW5zew==}
    engines: {node: '>=12.0.0'}

  tinypool@1.0.2:
    resolution: {integrity: sha512-al6n+QEANGFOMf/dmUMsuS5/r9B06uwlyNjZZql/zv8J7ybHCgoihBNORZCY2mzUuAnomQa2JdhyHKzZxPCrFA==}
    engines: {node: ^18.0.0 || >=20.0.0}

  tinyrainbow@2.0.0:
    resolution: {integrity: sha512-op4nsTR47R6p0vMUUoYl/a+ljLFVtlfaXkLQmqfLR1qHma1h/ysYk4hEXZ880bf2CYgTskvTa/e196Vd5dDQXw==}
    engines: {node: '>=14.0.0'}

  tinyspy@3.0.2:
    resolution: {integrity: sha512-n1cw8k1k0x4pgA2+9XrOkFydTerNcJ1zWCO5Nn9scWHTD+5tp8dghT2x1uduQePZTZgd3Tupf+x9BxJjeJi77Q==}
    engines: {node: '>=14.0.0'}

  tr46@1.0.1:
    resolution: {integrity: sha512-dTpowEjclQ7Kgx5SdBkqRzVhERQXov8/l9Ft9dVM9fmg0W0KQSVaXX9T4i6twCPNtYiZM53lpSSUAwJbFPOHxA==}

  tree-kill@1.2.2:
    resolution: {integrity: sha512-L0Orpi8qGpRG//Nd+H90vFB+3iHnue1zSSGmNOOCh1GLJ7rUKVwV2HvijphGQS2UmhUZewS9VgvxYIdgr+fG1A==}
    hasBin: true

  ts-interface-checker@0.1.13:
    resolution: {integrity: sha512-Y/arvbn+rrz3JCKl9C4kVNfTfSm2/mEp5FSz5EsZSANGPSlQrpRI5M4PKF+mJnE52jOO90PnPSc3Ur3bTQw0gA==}

  tsup@8.3.5:
    resolution: {integrity: sha512-Tunf6r6m6tnZsG9GYWndg0z8dEV7fD733VBFzFJ5Vcm1FtlXB8xBD/rtrBi2a3YKEV7hHtxiZtW5EAVADoe1pA==}
    engines: {node: '>=18'}
    hasBin: true
    peerDependencies:
      '@microsoft/api-extractor': ^7.36.0
      '@swc/core': ^1
      postcss: ^8.4.12
      typescript: '>=4.5.0'
    peerDependenciesMeta:
      '@microsoft/api-extractor':
        optional: true
      '@swc/core':
        optional: true
      postcss:
        optional: true
      typescript:
        optional: true

  type-fest@4.33.0:
    resolution: {integrity: sha512-s6zVrxuyKbbAsSAD5ZPTB77q4YIdRctkTbJ2/Dqlinwz+8ooH2gd+YA7VA6Pa93KML9GockVvoxjZ2vHP+mu8g==}
    engines: {node: '>=16'}

  typescript@5.6.1-rc:
    resolution: {integrity: sha512-E3b2+1zEFu84jB0YQi9BORDjz9+jGbwwy1Zi3G0LUNw7a7cePUrHMRNy8aPh53nXpkFGVHSxIZo5vKTfYaFiBQ==}
    engines: {node: '>=14.17'}
    hasBin: true

  typescript@5.7.3:
    resolution: {integrity: sha512-84MVSjMEHP+FQRPy3pX9sTVV/INIex71s9TL2Gm5FG/WG1SqXeKyZ0k7/blY/4FdOzI12CBy1vGc4og/eus0fw==}
    engines: {node: '>=14.17'}
    hasBin: true

  ufo@1.5.4:
    resolution: {integrity: sha512-UsUk3byDzKd04EyoZ7U4DOlxQaD14JUKQl6/P7wiX4FNvUfm3XL246n9W5AmqwW5RSFJ27NAuM0iLscAOYUiGQ==}

  uncrypto@0.1.3:
    resolution: {integrity: sha512-Ql87qFHB3s/De2ClA9e0gsnS6zXG27SkTiSJwjCc9MebbfapQfuPzumMIUMi38ezPZVNFcHI9sUIepeQfw8J8Q==}

  undici-types@5.26.5:
    resolution: {integrity: sha512-JlCMO+ehdEIKqlFxk6IfVoAUVmgz7cU7zD/h9XZ0qzeosSHmUJVOzSQvvYSYWXkFXC+IfLKSIffhv0sVZup6pA==}

  undici-types@6.20.0:
    resolution: {integrity: sha512-Ny6QZ2Nju20vw1SRHe3d9jVu6gJ+4e3+MMpqu7pqE5HT6WsTSlce++GQmK5UXS8mzV8DSYHrQH+Xrf2jVcuKNg==}

  unicode-emoji-modifier-base@1.0.0:
    resolution: {integrity: sha512-yLSH4py7oFH3oG/9K+XWrz1pSi3dfUrWEnInbxMfArOfc1+33BlGPQtLsOYwvdMy11AwUBetYuaRxSPqgkq+8g==}
    engines: {node: '>=4'}

  valibot@1.0.0-beta.15:
    resolution: {integrity: sha512-BKy8XosZkDHWmYC+cJG74LBzP++Gfntwi33pP3D3RKztz2XV9jmFWnkOi21GoqARP8wAWARwhV6eTr1JcWzjGw==}
    peerDependencies:
      typescript: '>=5'
    peerDependenciesMeta:
      typescript:
        optional: true

  validate-npm-package-name@5.0.1:
    resolution: {integrity: sha512-OljLrQ9SQdOUqTaQxqL5dEfZWrXExyyWsozYlAWFawPVNuD83igl7uJD2RTkNMbniIYgt8l81eCJGIdQF7avLQ==}
    engines: {node: ^14.17.0 || ^16.13.0 || >=18.0.0}

  vite-node@3.0.3:
    resolution: {integrity: sha512-0sQcwhwAEw/UJGojbhOrnq3HtiZ3tC7BzpAa0lx3QaTX0S3YX70iGcik25UBdB96pmdwjyY2uyKNYruxCDmiEg==}
    engines: {node: ^18.0.0 || ^20.0.0 || >=22.0.0}
    hasBin: true

  vite@5.4.14:
    resolution: {integrity: sha512-EK5cY7Q1D8JNhSaPKVK4pwBFvaTmZxEnoKXLG/U9gmdDcihQGNzFlgIvaxezFR4glP1LsuiedwMBqCXH3wZccA==}
    engines: {node: ^18.0.0 || >=20.0.0}
    hasBin: true
    peerDependencies:
      '@types/node': ^18.0.0 || >=20.0.0
      less: '*'
      lightningcss: ^1.21.0
      sass: '*'
      sass-embedded: '*'
      stylus: '*'
      sugarss: '*'
      terser: ^5.4.0
    peerDependenciesMeta:
      '@types/node':
        optional: true
      less:
        optional: true
      lightningcss:
        optional: true
      sass:
        optional: true
      sass-embedded:
        optional: true
      stylus:
        optional: true
      sugarss:
        optional: true
      terser:
        optional: true

  vitest@3.0.3:
    resolution: {integrity: sha512-dWdwTFUW9rcnL0LyF2F+IfvNQWB0w9DERySCk8VMG75F8k25C7LsZoh6XfCjPvcR8Nb+Lqi9JKr6vnzH7HSrpQ==}
    engines: {node: ^18.0.0 || ^20.0.0 || >=22.0.0}
    hasBin: true
    peerDependencies:
      '@edge-runtime/vm': '*'
      '@types/node': ^18.0.0 || ^20.0.0 || >=22.0.0
      '@vitest/browser': 3.0.3
      '@vitest/ui': 3.0.3
      happy-dom: '*'
      jsdom: '*'
    peerDependenciesMeta:
      '@edge-runtime/vm':
        optional: true
      '@types/node':
        optional: true
      '@vitest/browser':
        optional: true
      '@vitest/ui':
        optional: true
      happy-dom:
        optional: true
      jsdom:
        optional: true

  webidl-conversions@4.0.2:
    resolution: {integrity: sha512-YQ+BmxuTgd6UXZW3+ICGfyqRyHXVlD5GtQr5+qjiNW7bF0cqrzX500HVXPBOvgXb5YnzDd+h0zqyv61KUD7+Sg==}

  whatwg-url@7.1.0:
    resolution: {integrity: sha512-WUu7Rg1DroM7oQvGWfOiAK21n74Gg+T4elXEQYkOhtyLeWiJFoOGLXPKI/9gzIie9CtwVLm8wtw6YJdKyxSjeg==}

  which@2.0.2:
    resolution: {integrity: sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==}
    engines: {node: '>= 8'}
    hasBin: true

  why-is-node-running@2.3.0:
    resolution: {integrity: sha512-hUrmaWBdVDcxvYqnyh09zunKzROWjbZTiNy8dBEjkS7ehEDQibXJ7XvlmtbwuTclUiIyN+CyXQD4Vmko8fNm8w==}
    engines: {node: '>=8'}
    hasBin: true

  wrap-ansi@7.0.0:
    resolution: {integrity: sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==}
    engines: {node: '>=10'}

  wrap-ansi@8.1.0:
    resolution: {integrity: sha512-si7QWI6zUMq56bESFvagtmzMdGOtoxfR+Sez11Mobfc7tm+VkUckk9bW2UeffTGVUbOksxmSw0AA2gs8g71NCQ==}
    engines: {node: '>=12'}

  y18n@5.0.8:
    resolution: {integrity: sha512-0pfFzegeDWJHJIAmTLRP2DwHjdF5s7jo9tuztdQxAhINCdvS+3nGINqPd00AphqJR/0LhANUS6/+7SCb98YOfA==}
    engines: {node: '>=10'}

  yallist@4.0.0:
    resolution: {integrity: sha512-3wdGidZyq5PB084XLES5TpOSRA3wjXAlIWMhum2kRcv/41Sn2emQ0dycQW4uZXLejwKvg6EsvbdlVL+FYEct7A==}

  yargs-parser@20.2.9:
    resolution: {integrity: sha512-y11nGElTIV+CT3Zv9t7VKl+Q3hTQoT9a1Qzezhhl6Rp21gJ/IVTW7Z3y9EWXhuUBC2Shnf+DX0antecpAwSP8w==}
    engines: {node: '>=10'}

  yargs@16.2.0:
    resolution: {integrity: sha512-D1mvvtDG0L5ft/jGWkLpG1+m0eQxOfaBvTNELraWj22wSVUMWxZUvYgJYcKh6jGGIkJFhH4IZPQhR4TKpc8mBw==}
    engines: {node: '>=10'}

  zod@3.24.1:
    resolution: {integrity: sha512-muH7gBL9sI1nciMZV67X5fTKKBLtwpZ5VBp1vsOQzj1MhrBZ4wlVCm3gedKZWLp0Oyel8sIGfeiz54Su+OVT+A==}

snapshots:

  '@andrewbranch/untar.js@1.0.3': {}

  '@arethetypeswrong/cli@0.16.4':
    dependencies:
      '@arethetypeswrong/core': 0.16.4
      chalk: 4.1.2
      cli-table3: 0.6.5
      commander: 10.0.1
      marked: 9.1.6
      marked-terminal: 7.2.1(marked@9.1.6)
      semver: 7.6.3

  '@arethetypeswrong/core@0.16.4':
    dependencies:
      '@andrewbranch/untar.js': 1.0.3
      cjs-module-lexer: 1.4.1
      fflate: 0.8.2
      lru-cache: 10.4.3
      semver: 7.6.3
      typescript: 5.6.1-rc
      validate-npm-package-name: 5.0.1

  '@ark/schema@0.35.0':
    dependencies:
      '@ark/util': 0.35.0

  '@ark/util@0.35.0': {}

  '@better-fetch/fetch@1.1.12': {}

  '@biomejs/biome@1.9.4':
    optionalDependencies:
      '@biomejs/cli-darwin-arm64': 1.9.4
      '@biomejs/cli-darwin-x64': 1.9.4
      '@biomejs/cli-linux-arm64': 1.9.4
      '@biomejs/cli-linux-arm64-musl': 1.9.4
      '@biomejs/cli-linux-x64': 1.9.4
      '@biomejs/cli-linux-x64-musl': 1.9.4
      '@biomejs/cli-win32-arm64': 1.9.4
      '@biomejs/cli-win32-x64': 1.9.4

  '@biomejs/cli-darwin-arm64@1.9.4':
    optional: true

  '@biomejs/cli-darwin-x64@1.9.4':
    optional: true

  '@biomejs/cli-linux-arm64-musl@1.9.4':
    optional: true

  '@biomejs/cli-linux-arm64@1.9.4':
    optional: true

  '@biomejs/cli-linux-x64-musl@1.9.4':
    optional: true

  '@biomejs/cli-linux-x64@1.9.4':
    optional: true

  '@biomejs/cli-win32-arm64@1.9.4':
    optional: true

  '@biomejs/cli-win32-x64@1.9.4':
    optional: true

  '@colors/colors@1.5.0':
    optional: true

  '@esbuild/aix-ppc64@0.21.5':
    optional: true

  '@esbuild/aix-ppc64@0.24.2':
    optional: true

  '@esbuild/android-arm64@0.21.5':
    optional: true

  '@esbuild/android-arm64@0.24.2':
    optional: true

  '@esbuild/android-arm@0.21.5':
    optional: true

  '@esbuild/android-arm@0.24.2':
    optional: true

  '@esbuild/android-x64@0.21.5':
    optional: true

  '@esbuild/android-x64@0.24.2':
    optional: true

  '@esbuild/darwin-arm64@0.21.5':
    optional: true

  '@esbuild/darwin-arm64@0.24.2':
    optional: true

  '@esbuild/darwin-x64@0.21.5':
    optional: true

  '@esbuild/darwin-x64@0.24.2':
    optional: true

  '@esbuild/freebsd-arm64@0.21.5':
    optional: true

  '@esbuild/freebsd-arm64@0.24.2':
    optional: true

  '@esbuild/freebsd-x64@0.21.5':
    optional: true

  '@esbuild/freebsd-x64@0.24.2':
    optional: true

  '@esbuild/linux-arm64@0.21.5':
    optional: true

  '@esbuild/linux-arm64@0.24.2':
    optional: true

  '@esbuild/linux-arm@0.21.5':
    optional: true

  '@esbuild/linux-arm@0.24.2':
    optional: true

  '@esbuild/linux-ia32@0.21.5':
    optional: true

  '@esbuild/linux-ia32@0.24.2':
    optional: true

  '@esbuild/linux-loong64@0.21.5':
    optional: true

  '@esbuild/linux-loong64@0.24.2':
    optional: true

  '@esbuild/linux-mips64el@0.21.5':
    optional: true

  '@esbuild/linux-mips64el@0.24.2':
    optional: true

  '@esbuild/linux-ppc64@0.21.5':
    optional: true

  '@esbuild/linux-ppc64@0.24.2':
    optional: true

  '@esbuild/linux-riscv64@0.21.5':
    optional: true

  '@esbuild/linux-riscv64@0.24.2':
    optional: true

  '@esbuild/linux-s390x@0.21.5':
    optional: true

  '@esbuild/linux-s390x@0.24.2':
    optional: true

  '@esbuild/linux-x64@0.21.5':
    optional: true

  '@esbuild/linux-x64@0.24.2':
    optional: true

  '@esbuild/netbsd-arm64@0.24.2':
    optional: true

  '@esbuild/netbsd-x64@0.21.5':
    optional: true

  '@esbuild/netbsd-x64@0.24.2':
    optional: true

  '@esbuild/openbsd-arm64@0.24.2':
    optional: true

  '@esbuild/openbsd-x64@0.21.5':
    optional: true

  '@esbuild/openbsd-x64@0.24.2':
    optional: true

  '@esbuild/sunos-x64@0.21.5':
    optional: true

  '@esbuild/sunos-x64@0.24.2':
    optional: true

  '@esbuild/win32-arm64@0.21.5':
    optional: true

  '@esbuild/win32-arm64@0.24.2':
    optional: true

  '@esbuild/win32-ia32@0.21.5':
    optional: true

  '@esbuild/win32-ia32@0.24.2':
    optional: true

  '@esbuild/win32-x64@0.21.5':
    optional: true

  '@esbuild/win32-x64@0.24.2':
    optional: true

  '@isaacs/cliui@8.0.2':
    dependencies:
      string-width: 5.1.2
      string-width-cjs: string-width@4.2.3
      strip-ansi: 7.1.0
      strip-ansi-cjs: strip-ansi@6.0.1
      wrap-ansi: 8.1.0
      wrap-ansi-cjs: wrap-ansi@7.0.0

  '@jridgewell/gen-mapping@0.3.8':
    dependencies:
      '@jridgewell/set-array': 1.2.1
      '@jridgewell/sourcemap-codec': 1.5.0
      '@jridgewell/trace-mapping': 0.3.25

  '@jridgewell/resolve-uri@3.1.2': {}

  '@jridgewell/set-array@1.2.1': {}

  '@jridgewell/sourcemap-codec@1.5.0': {}

  '@jridgewell/trace-mapping@0.3.25':
    dependencies:
      '@jridgewell/resolve-uri': 3.1.2
      '@jridgewell/sourcemap-codec': 1.5.0

  '@pkgjs/parseargs@0.11.0':
    optional: true

  '@rollup/rollup-android-arm-eabi@4.31.0':
    optional: true

  '@rollup/rollup-android-arm64@4.31.0':
    optional: true

  '@rollup/rollup-darwin-arm64@4.31.0':
    optional: true

  '@rollup/rollup-darwin-x64@4.31.0':
    optional: true

  '@rollup/rollup-freebsd-arm64@4.31.0':
    optional: true

  '@rollup/rollup-freebsd-x64@4.31.0':
    optional: true

  '@rollup/rollup-linux-arm-gnueabihf@4.31.0':
    optional: true

  '@rollup/rollup-linux-arm-musleabihf@4.31.0':
    optional: true

  '@rollup/rollup-linux-arm64-gnu@4.31.0':
    optional: true

  '@rollup/rollup-linux-arm64-musl@4.31.0':
    optional: true

  '@rollup/rollup-linux-loongarch64-gnu@4.31.0':
    optional: true

  '@rollup/rollup-linux-powerpc64le-gnu@4.31.0':
    optional: true

  '@rollup/rollup-linux-riscv64-gnu@4.31.0':
    optional: true

  '@rollup/rollup-linux-s390x-gnu@4.31.0':
    optional: true

  '@rollup/rollup-linux-x64-gnu@4.31.0':
    optional: true

  '@rollup/rollup-linux-x64-musl@4.31.0':
    optional: true

  '@rollup/rollup-win32-arm64-msvc@4.31.0':
    optional: true

  '@rollup/rollup-win32-ia32-msvc@4.31.0':
    optional: true

  '@rollup/rollup-win32-x64-msvc@4.31.0':
    optional: true

  '@sindresorhus/is@4.6.0': {}

  '@types/bun@1.1.18':
    dependencies:
      bun-types: 1.1.44

  '@types/estree@1.0.6': {}

  '@types/node@20.12.14':
    dependencies:
      undici-types: 5.26.5

  '@types/node@22.10.7':
    dependencies:
      undici-types: 6.20.0

  '@types/set-cookie-parser@2.4.10':
    dependencies:
      '@types/node': 22.10.7

  '@types/ws@8.5.13':
    dependencies:
      '@types/node': 20.12.14

  '@vitest/expect@3.0.3':
    dependencies:
      '@vitest/spy': 3.0.3
      '@vitest/utils': 3.0.3
      chai: 5.1.2
      tinyrainbow: 2.0.0

  '@vitest/mocker@3.0.3(vite@5.4.14(@types/node@22.10.7))':
    dependencies:
      '@vitest/spy': 3.0.3
      estree-walker: 3.0.3
      magic-string: 0.30.17
    optionalDependencies:
      vite: 5.4.14(@types/node@22.10.7)

  '@vitest/pretty-format@3.0.3':
    dependencies:
      tinyrainbow: 2.0.0

  '@vitest/runner@3.0.3':
    dependencies:
      '@vitest/utils': 3.0.3
      pathe: 2.0.2

  '@vitest/snapshot@3.0.3':
    dependencies:
      '@vitest/pretty-format': 3.0.3
      magic-string: 0.30.17
      pathe: 2.0.2

  '@vitest/spy@3.0.3':
    dependencies:
      tinyspy: 3.0.2

  '@vitest/utils@3.0.3':
    dependencies:
      '@vitest/pretty-format': 3.0.3
      loupe: 3.1.2
      tinyrainbow: 2.0.0

  acorn@8.14.0: {}

  ansi-escapes@7.0.0:
    dependencies:
      environment: 1.1.0

  ansi-regex@5.0.1: {}

  ansi-regex@6.1.0: {}

  ansi-styles@4.3.0:
    dependencies:
      color-convert: 2.0.1

  ansi-styles@6.2.1: {}

  any-promise@1.3.0: {}

  argparse@2.0.1: {}

  arktype@2.0.0:
    dependencies:
      '@ark/schema': 0.35.0
      '@ark/util': 0.35.0

  assertion-error@2.0.1: {}

  balanced-match@1.0.2: {}

  brace-expansion@2.0.1:
    dependencies:
      balanced-match: 1.0.2

  bumpp@9.10.1:
    dependencies:
      c12: 2.0.1
      cac: 6.7.14
      escalade: 3.2.0
      js-yaml: 4.1.0
      jsonc-parser: 3.3.1
      package-manager-detector: 0.2.8
      prompts: 2.4.2
      semver: 7.6.3
      tinyexec: 0.3.2
      tinyglobby: 0.2.10
    transitivePeerDependencies:
      - magicast

  bun-types@1.1.44:
    dependencies:
      '@types/node': 20.12.14
      '@types/ws': 8.5.13

  bundle-require@5.1.0(esbuild@0.24.2):
    dependencies:
      esbuild: 0.24.2
      load-tsconfig: 0.2.5

  c12@2.0.1:
    dependencies:
      chokidar: 4.0.3
      confbox: 0.1.8
      defu: 6.1.4
      dotenv: 16.4.7
      giget: 1.2.3
      jiti: 2.4.2
      mlly: 1.7.4
      ohash: 1.1.4
      pathe: 1.1.2
      perfect-debounce: 1.0.0
      pkg-types: 1.3.1
      rc9: 2.1.2

  cac@6.7.14: {}

  chai@5.1.2:
    dependencies:
      assertion-error: 2.0.1
      check-error: 2.1.1
      deep-eql: 5.0.2
      loupe: 3.1.2
      pathval: 2.0.0

  chalk@4.1.2:
    dependencies:
      ansi-styles: 4.3.0
      supports-color: 7.2.0

  chalk@5.4.1: {}

  char-regex@1.0.2: {}

  check-error@2.1.1: {}

  chokidar@4.0.3:
    dependencies:
      readdirp: 4.1.1

  chownr@2.0.0: {}

  citty@0.1.6:
    dependencies:
      consola: 3.4.0

  cjs-module-lexer@1.4.1: {}

  cli-highlight@2.1.11:
    dependencies:
      chalk: 4.1.2
      highlight.js: 10.7.3
      mz: 2.7.0
      parse5: 5.1.1
      parse5-htmlparser2-tree-adapter: 6.0.1
      yargs: 16.2.0

  cli-table3@0.6.5:
    dependencies:
      string-width: 4.2.3
    optionalDependencies:
      '@colors/colors': 1.5.0

  cliui@7.0.4:
    dependencies:
      string-width: 4.2.3
      strip-ansi: 6.0.1
      wrap-ansi: 7.0.0

  color-convert@2.0.1:
    dependencies:
      color-name: 1.1.4

  color-name@1.1.4: {}

  commander@10.0.1: {}

  commander@4.1.1: {}

  confbox@0.1.8: {}

  consola@3.4.0: {}

  cross-spawn@7.0.6:
    dependencies:
      path-key: 3.1.1
      shebang-command: 2.0.0
      which: 2.0.2

  debug@4.4.0:
    dependencies:
      ms: 2.1.3

  deep-eql@5.0.2: {}

  defu@6.1.4: {}

  destr@2.0.3: {}

  dotenv@16.4.7: {}

  eastasianwidth@0.2.0: {}

  emoji-regex@8.0.0: {}

  emoji-regex@9.2.2: {}

  emojilib@2.4.0: {}

  environment@1.1.0: {}

  es-module-lexer@1.6.0: {}

  esbuild@0.21.5:
    optionalDependencies:
      '@esbuild/aix-ppc64': 0.21.5
      '@esbuild/android-arm': 0.21.5
      '@esbuild/android-arm64': 0.21.5
      '@esbuild/android-x64': 0.21.5
      '@esbuild/darwin-arm64': 0.21.5
      '@esbuild/darwin-x64': 0.21.5
      '@esbuild/freebsd-arm64': 0.21.5
      '@esbuild/freebsd-x64': 0.21.5
      '@esbuild/linux-arm': 0.21.5
      '@esbuild/linux-arm64': 0.21.5
      '@esbuild/linux-ia32': 0.21.5
      '@esbuild/linux-loong64': 0.21.5
      '@esbuild/linux-mips64el': 0.21.5
      '@esbuild/linux-ppc64': 0.21.5
      '@esbuild/linux-riscv64': 0.21.5
      '@esbuild/linux-s390x': 0.21.5
      '@esbuild/linux-x64': 0.21.5
      '@esbuild/netbsd-x64': 0.21.5
      '@esbuild/openbsd-x64': 0.21.5
      '@esbuild/sunos-x64': 0.21.5
      '@esbuild/win32-arm64': 0.21.5
      '@esbuild/win32-ia32': 0.21.5
      '@esbuild/win32-x64': 0.21.5

  esbuild@0.24.2:
    optionalDependencies:
      '@esbuild/aix-ppc64': 0.24.2
      '@esbuild/android-arm': 0.24.2
      '@esbuild/android-arm64': 0.24.2
      '@esbuild/android-x64': 0.24.2
      '@esbuild/darwin-arm64': 0.24.2
      '@esbuild/darwin-x64': 0.24.2
      '@esbuild/freebsd-arm64': 0.24.2
      '@esbuild/freebsd-x64': 0.24.2
      '@esbuild/linux-arm': 0.24.2
      '@esbuild/linux-arm64': 0.24.2
      '@esbuild/linux-ia32': 0.24.2
      '@esbuild/linux-loong64': 0.24.2
      '@esbuild/linux-mips64el': 0.24.2
      '@esbuild/linux-ppc64': 0.24.2
      '@esbuild/linux-riscv64': 0.24.2
      '@esbuild/linux-s390x': 0.24.2
      '@esbuild/linux-x64': 0.24.2
      '@esbuild/netbsd-arm64': 0.24.2
      '@esbuild/netbsd-x64': 0.24.2
      '@esbuild/openbsd-arm64': 0.24.2
      '@esbuild/openbsd-x64': 0.24.2
      '@esbuild/sunos-x64': 0.24.2
      '@esbuild/win32-arm64': 0.24.2
      '@esbuild/win32-ia32': 0.24.2
      '@esbuild/win32-x64': 0.24.2

  escalade@3.2.0: {}

  estree-walker@3.0.3:
    dependencies:
      '@types/estree': 1.0.6

  execa@8.0.1:
    dependencies:
      cross-spawn: 7.0.6
      get-stream: 8.0.1
      human-signals: 5.0.0
      is-stream: 3.0.0
      merge-stream: 2.0.0
      npm-run-path: 5.3.0
      onetime: 6.0.0
      signal-exit: 4.1.0
      strip-final-newline: 3.0.0

  expect-type@1.1.0: {}

  fdir@6.4.3(picomatch@4.0.2):
    optionalDependencies:
      picomatch: 4.0.2

  fflate@0.8.2: {}

  foreground-child@3.3.0:
    dependencies:
      cross-spawn: 7.0.6
      signal-exit: 4.1.0

  fs-minipass@2.1.0:
    dependencies:
      minipass: 3.3.6

  fsevents@2.3.3:
    optional: true

  get-caller-file@2.0.5: {}

  get-stream@8.0.1: {}

  giget@1.2.3:
    dependencies:
      citty: 0.1.6
      consola: 3.4.0
      defu: 6.1.4
      node-fetch-native: 1.6.6
      nypm: 0.3.12
      ohash: 1.1.4
      pathe: 1.1.2
      tar: 6.2.1

  glob@10.4.5:
    dependencies:
      foreground-child: 3.3.0
      jackspeak: 3.4.3
      minimatch: 9.0.5
      minipass: 7.1.2
      package-json-from-dist: 1.0.1
      path-scurry: 1.11.1

  has-flag@4.0.0: {}

  highlight.js@10.7.3: {}

  human-signals@5.0.0: {}

  is-fullwidth-code-point@3.0.0: {}

  is-stream@3.0.0: {}

  isexe@2.0.0: {}

  jackspeak@3.4.3:
    dependencies:
      '@isaacs/cliui': 8.0.2
    optionalDependencies:
      '@pkgjs/parseargs': 0.11.0

  jiti@2.4.2: {}

  joycon@3.1.1: {}

  js-yaml@4.1.0:
    dependencies:
      argparse: 2.0.1

  jsonc-parser@3.3.1: {}

  kleur@3.0.3: {}

  lilconfig@3.1.3: {}

  lines-and-columns@1.2.4: {}

  load-tsconfig@0.2.5: {}

  lodash.sortby@4.7.0: {}

  loupe@3.1.2: {}

  lru-cache@10.4.3: {}

  magic-string@0.30.17:
    dependencies:
      '@jridgewell/sourcemap-codec': 1.5.0

  marked-terminal@7.2.1(marked@9.1.6):
    dependencies:
      ansi-escapes: 7.0.0
      ansi-regex: 6.1.0
      chalk: 5.4.1
      cli-highlight: 2.1.11
      cli-table3: 0.6.5
      marked: 9.1.6
      node-emoji: 2.2.0
      supports-hyperlinks: 3.1.0

  marked@9.1.6: {}

  merge-stream@2.0.0: {}

  mimic-fn@4.0.0: {}

  minimatch@9.0.5:
    dependencies:
      brace-expansion: 2.0.1

  minipass@3.3.6:
    dependencies:
      yallist: 4.0.0

  minipass@5.0.0: {}

  minipass@7.1.2: {}

  minizlib@2.1.2:
    dependencies:
      minipass: 3.3.6
      yallist: 4.0.0

  mkdirp@1.0.4: {}

  mlly@1.7.4:
    dependencies:
      acorn: 8.14.0
      pathe: 2.0.2
      pkg-types: 1.3.1
      ufo: 1.5.4

  ms@2.1.3: {}

  mz@2.7.0:
    dependencies:
      any-promise: 1.3.0
      object-assign: 4.1.1
      thenify-all: 1.6.0

  nanoid@3.3.8: {}

  node-emoji@2.2.0:
    dependencies:
      '@sindresorhus/is': 4.6.0
      char-regex: 1.0.2
      emojilib: 2.4.0
      skin-tone: 2.0.0

  node-fetch-native@1.6.6: {}

  npm-run-path@5.3.0:
    dependencies:
      path-key: 4.0.0

  nypm@0.3.12:
    dependencies:
      citty: 0.1.6
      consola: 3.4.0
      execa: 8.0.1
      pathe: 1.1.2
      pkg-types: 1.3.1
      ufo: 1.5.4

  object-assign@4.1.1: {}

  ohash@1.1.4: {}

  onetime@6.0.0:
    dependencies:
      mimic-fn: 4.0.0

  package-json-from-dist@1.0.1: {}

  package-manager-detector@0.2.8: {}

  parse5-htmlparser2-tree-adapter@6.0.1:
    dependencies:
      parse5: 6.0.1

  parse5@5.1.1: {}

  parse5@6.0.1: {}

  path-key@3.1.1: {}

  path-key@4.0.0: {}

  path-scurry@1.11.1:
    dependencies:
      lru-cache: 10.4.3
      minipass: 7.1.2

  pathe@1.1.2: {}

  pathe@2.0.2: {}

  pathval@2.0.0: {}

  perfect-debounce@1.0.0: {}

  picocolors@1.1.1: {}

  picomatch@4.0.2: {}

  pirates@4.0.6: {}

  pkg-types@1.3.1:
    dependencies:
      confbox: 0.1.8
      mlly: 1.7.4
      pathe: 2.0.2

  postcss-load-config@6.0.1(jiti@2.4.2)(postcss@8.5.1):
    dependencies:
      lilconfig: 3.1.3
    optionalDependencies:
      jiti: 2.4.2
      postcss: 8.5.1

  postcss@8.5.1:
    dependencies:
      nanoid: 3.3.8
      picocolors: 1.1.1
      source-map-js: 1.2.1

  prompts@2.4.2:
    dependencies:
      kleur: 3.0.3
      sisteransi: 1.0.5

  punycode@2.3.1: {}

  rc9@2.1.2:
    dependencies:
      defu: 6.1.4
      destr: 2.0.3

  readdirp@4.1.1: {}

  require-directory@2.1.1: {}

  resolve-from@5.0.0: {}

  rollup@4.31.0:
    dependencies:
      '@types/estree': 1.0.6
    optionalDependencies:
      '@rollup/rollup-android-arm-eabi': 4.31.0
      '@rollup/rollup-android-arm64': 4.31.0
      '@rollup/rollup-darwin-arm64': 4.31.0
      '@rollup/rollup-darwin-x64': 4.31.0
      '@rollup/rollup-freebsd-arm64': 4.31.0
      '@rollup/rollup-freebsd-x64': 4.31.0
      '@rollup/rollup-linux-arm-gnueabihf': 4.31.0
      '@rollup/rollup-linux-arm-musleabihf': 4.31.0
      '@rollup/rollup-linux-arm64-gnu': 4.31.0
      '@rollup/rollup-linux-arm64-musl': 4.31.0
      '@rollup/rollup-linux-loongarch64-gnu': 4.31.0
      '@rollup/rollup-linux-powerpc64le-gnu': 4.31.0
      '@rollup/rollup-linux-riscv64-gnu': 4.31.0
      '@rollup/rollup-linux-s390x-gnu': 4.31.0
      '@rollup/rollup-linux-x64-gnu': 4.31.0
      '@rollup/rollup-linux-x64-musl': 4.31.0
      '@rollup/rollup-win32-arm64-msvc': 4.31.0
      '@rollup/rollup-win32-ia32-msvc': 4.31.0
      '@rollup/rollup-win32-x64-msvc': 4.31.0
      fsevents: 2.3.3

  rou3@0.5.1: {}

  semver@7.6.3: {}

  set-cookie-parser@2.7.1: {}

  shebang-command@2.0.0:
    dependencies:
      shebang-regex: 3.0.0

  shebang-regex@3.0.0: {}

  siginfo@2.0.0: {}

  signal-exit@4.1.0: {}

  sisteransi@1.0.5: {}

  skin-tone@2.0.0:
    dependencies:
      unicode-emoji-modifier-base: 1.0.0

  source-map-js@1.2.1: {}

  source-map@0.8.0-beta.0:
    dependencies:
      whatwg-url: 7.1.0

  stackback@0.0.2: {}

  std-env@3.8.0: {}

  string-width@4.2.3:
    dependencies:
      emoji-regex: 8.0.0
      is-fullwidth-code-point: 3.0.0
      strip-ansi: 6.0.1

  string-width@5.1.2:
    dependencies:
      eastasianwidth: 0.2.0
      emoji-regex: 9.2.2
      strip-ansi: 7.1.0

  strip-ansi@6.0.1:
    dependencies:
      ansi-regex: 5.0.1

  strip-ansi@7.1.0:
    dependencies:
      ansi-regex: 6.1.0

  strip-final-newline@3.0.0: {}

  sucrase@3.35.0:
    dependencies:
      '@jridgewell/gen-mapping': 0.3.8
      commander: 4.1.1
      glob: 10.4.5
      lines-and-columns: 1.2.4
      mz: 2.7.0
      pirates: 4.0.6
      ts-interface-checker: 0.1.13

  supports-color@7.2.0:
    dependencies:
      has-flag: 4.0.0

  supports-hyperlinks@3.1.0:
    dependencies:
      has-flag: 4.0.0
      supports-color: 7.2.0

  tar@6.2.1:
    dependencies:
      chownr: 2.0.0
      fs-minipass: 2.1.0
      minipass: 5.0.0
      minizlib: 2.1.2
      mkdirp: 1.0.4
      yallist: 4.0.0

  thenify-all@1.6.0:
    dependencies:
      thenify: 3.3.1

  thenify@3.3.1:
    dependencies:
      any-promise: 1.3.0

  tinybench@2.9.0: {}

  tinyexec@0.3.2: {}

  tinyglobby@0.2.10:
    dependencies:
      fdir: 6.4.3(picomatch@4.0.2)
      picomatch: 4.0.2

  tinypool@1.0.2: {}

  tinyrainbow@2.0.0: {}

  tinyspy@3.0.2: {}

  tr46@1.0.1:
    dependencies:
      punycode: 2.3.1

  tree-kill@1.2.2: {}

  ts-interface-checker@0.1.13: {}

  tsup@8.3.5(jiti@2.4.2)(postcss@8.5.1)(typescript@5.7.3):
    dependencies:
      bundle-require: 5.1.0(esbuild@0.24.2)
      cac: 6.7.14
      chokidar: 4.0.3
      consola: 3.4.0
      debug: 4.4.0
      esbuild: 0.24.2
      joycon: 3.1.1
      picocolors: 1.1.1
      postcss-load-config: 6.0.1(jiti@2.4.2)(postcss@8.5.1)
      resolve-from: 5.0.0
      rollup: 4.31.0
      source-map: 0.8.0-beta.0
      sucrase: 3.35.0
      tinyexec: 0.3.2
      tinyglobby: 0.2.10
      tree-kill: 1.2.2
    optionalDependencies:
      postcss: 8.5.1
      typescript: 5.7.3
    transitivePeerDependencies:
      - jiti
      - supports-color
      - tsx
      - yaml

  type-fest@4.33.0: {}

  typescript@5.6.1-rc: {}

  typescript@5.7.3: {}

  ufo@1.5.4: {}

  uncrypto@0.1.3: {}

  undici-types@5.26.5: {}

  undici-types@6.20.0: {}

  unicode-emoji-modifier-base@1.0.0: {}

  valibot@1.0.0-beta.15(typescript@5.7.3):
    optionalDependencies:
      typescript: 5.7.3

  validate-npm-package-name@5.0.1: {}

  vite-node@3.0.3(@types/node@22.10.7):
    dependencies:
      cac: 6.7.14
      debug: 4.4.0
      es-module-lexer: 1.6.0
      pathe: 2.0.2
      vite: 5.4.14(@types/node@22.10.7)
    transitivePeerDependencies:
      - '@types/node'
      - less
      - lightningcss
      - sass
      - sass-embedded
      - stylus
      - sugarss
      - supports-color
      - terser

  vite@5.4.14(@types/node@22.10.7):
    dependencies:
      esbuild: 0.21.5
      postcss: 8.5.1
      rollup: 4.31.0
    optionalDependencies:
      '@types/node': 22.10.7
      fsevents: 2.3.3

  vitest@3.0.3(@types/node@22.10.7):
    dependencies:
      '@vitest/expect': 3.0.3
      '@vitest/mocker': 3.0.3(vite@5.4.14(@types/node@22.10.7))
      '@vitest/pretty-format': 3.0.3
      '@vitest/runner': 3.0.3
      '@vitest/snapshot': 3.0.3
      '@vitest/spy': 3.0.3
      '@vitest/utils': 3.0.3
      chai: 5.1.2
      debug: 4.4.0
      expect-type: 1.1.0
      magic-string: 0.30.17
      pathe: 2.0.2
      std-env: 3.8.0
      tinybench: 2.9.0
      tinyexec: 0.3.2
      tinypool: 1.0.2
      tinyrainbow: 2.0.0
      vite: 5.4.14(@types/node@22.10.7)
      vite-node: 3.0.3(@types/node@22.10.7)
      why-is-node-running: 2.3.0
    optionalDependencies:
      '@types/node': 22.10.7
    transitivePeerDependencies:
      - less
      - lightningcss
      - msw
      - sass
      - sass-embedded
      - stylus
      - sugarss
      - supports-color
      - terser

  webidl-conversions@4.0.2: {}

  whatwg-url@7.1.0:
    dependencies:
      lodash.sortby: 4.7.0
      tr46: 1.0.1
      webidl-conversions: 4.0.2

  which@2.0.2:
    dependencies:
      isexe: 2.0.0

  why-is-node-running@2.3.0:
    dependencies:
      siginfo: 2.0.0
      stackback: 0.0.2

  wrap-ansi@7.0.0:
    dependencies:
      ansi-styles: 4.3.0
      string-width: 4.2.3
      strip-ansi: 6.0.1

  wrap-ansi@8.1.0:
    dependencies:
      ansi-styles: 6.2.1
      string-width: 5.1.2
      strip-ansi: 7.1.0

  y18n@5.0.8: {}

  yallist@4.0.0: {}

  yargs-parser@20.2.9: {}

  yargs@16.2.0:
    dependencies:
      cliui: 7.0.4
      escalade: 3.2.0
      get-caller-file: 2.0.5
      require-directory: 2.1.1
      string-width: 4.2.3
      y18n: 5.0.8
      yargs-parser: 20.2.9

  zod@3.24.1: {}



================================================
File: tsconfig.json
================================================
{
	"compilerOptions": {
		"esModuleInterop": true,
		"skipLibCheck": true,
		"target": "es2022",
		"allowJs": true,
		"resolveJsonModule": true,
		"moduleDetection": "force",
		"isolatedModules": true,
		"verbatimModuleSyntax": true,
		"strict": true,
		"module": "preserve",
		"noEmit": true,
		"lib": ["es2022", "dom", "dom.iterable"],
		"baseUrl": "."
	},
	"exclude": ["dist", "node_modules"]
}



================================================
File: tsup.config.ts
================================================
import { defineConfig } from "tsup";

export default defineConfig({
	entry: {
		index: "src/index.ts",
		client: "src/client.ts",
		node: "src/adapters/node/index.ts",
	},
	splitting: false,
	sourcemap: true,
	format: ["esm", "cjs"],
	target: "es2020",
	bundle: true,
});



================================================
File: example/hello.ts
================================================
import { createEndpoint } from "../src/endpoint";
import { createRouter } from "../src/router";
import { z } from "zod";

const hello = createEndpoint(
	"/hello",
	{
		method: "POST",
		body: z.object({
			name: z.string(),
		}),
		metadata: {
			openapi: {
				responses: {
					"200": {
						description: "Welcome Page",
						content: {
							"text/plain": {
								schema: {
									type: "string",
								},
							},
						},
					},
				},
			},
		},
	},
	async (c) => {
		c.setCookie("hello", "world");
		c.setCookie("test", "value");
		return "hello from better-call!";
	},
);

const router = createRouter({ hello });

Bun.serve({
	fetch: router.handler,
});



================================================
File: src/client.test.ts
================================================
import { describe, expect, expectTypeOf, it } from "vitest";
import { createClient } from "../src/client";
import { z } from "zod";
import { createEndpoint } from "./endpoint";
import { createRouter } from "./router";
import { createMiddleware } from "./middleware";

describe("client", () => {
	const getEndpoint = createEndpoint(
		"/test2",
		{
			method: "GET",
			query: z.object({
				hello: z.string(),
			}),
		},
		async (ctx) => {
			return {
				status: 200,
				body: {
					hello: "world",
				},
			};
		},
	);
	const endpoint = createEndpoint(
		"/test",
		{
			method: "POST",
			body: z.object({
				hello: z.string(),
			}),
		},
		async (ctx) => {
			return {
				status: 200,
				body: {
					hello: "world",
				},
			};
		},
	);

	const endpoint2 = createEndpoint(
		"/test3",
		{
			method: "GET",
			query: z.object({
				hello: z.string().optional(),
			}),
		},
		async (ctx) => {
			return {
				status: 200,
				body: {
					hello: "world",
				},
			};
		},
	);
	it("should send request and get response", async () => {
		const router = createRouter({
			endpoint,
			endpoint2,
			getEndpoint,
		});

		const client = createClient<typeof router>({
			baseURL: "http://localhost:3000",
			customFetchImpl: async (url, init) => {
				return router.handler(new Request(url, init));
			},
		});

		expectTypeOf<Parameters<typeof client>[0]>().toMatchTypeOf<
			"@post/test" | "/test2" | "/test3"
		>();

		const response = await client("@post/test", {
			body: {
				hello: "world",
			},
		});
		expect(response.data).toMatchObject({ status: 200, body: { hello: "world" } });
	});

	it("should infer types", () => {
		const router = createRouter({
			endpoint,
			endpoint2,
			getEndpoint,
		});

		const client = createClient<typeof router>({
			baseURL: "http://localhost:3000",
			customFetchImpl: async (url, init) => {
				return new Response(null);
			},
		});

		expectTypeOf<Parameters<typeof client>[0]>().toMatchTypeOf<
			"@post/test" | "/test2" | "/test3"
		>();

		client("@post/test", {
			body: {
				//@ts-expect-error
				hello: 1,
			},
		});

		client("/test2", {
			query: {
				//@ts-expect-error
				hello: 2,
			},
		});
		client("/test3", {
			query: {},
		});
	});

	it("should call endpoint n", async () => {
		const endpoint = createEndpoint(
			"/test",
			{
				method: "POST",
				body: z.object({
					hello: z.string(),
				}),
			},
			async (ctx) => {
				return {
					status: 200,
					body: {
						hello: "world",
					},
				};
			},
		);
		const endpoint2 = createEndpoint(
			"/test2",
			{
				method: "GET",
			},
			async (ctx) => {
				return {
					status: 200,
					body: {
						hello: "world",
					},
				};
			},
		);

		const router = createRouter({
			endpoint,
			endpoint2,
		});

		const client = createClient<typeof router>({
			baseURL: "http://localhost:3000",
		});
		await client("@post/test", {
			body: {
				hello: "world",
			},
			customFetchImpl: async (url, init) => {
				expect(url.toString()).toBe("http://localhost:3000/test");
				expect(init?.method).toBe("POST");
				expect(init?.body).toBe('{"hello":"world"}');
				return new Response(null);
			},
		});
		await client("/test2", {
			customFetchImpl: async (url, init) => {
				expect(url.toString()).toBe("http://localhost:3000/test2");
				expect(init?.method).toBe("GET");
				return new Response(null);
			},
		});
	});

	it("should infer from custom creator", () => {
		const cr2 = createEndpoint.create({
			use: [
				createMiddleware(async (ctx) => {
					return {
						something: "",
					};
				}),
			],
		});

		const endpoint = cr2(
			"/test",
			{
				method: "POST",
			},
			async (ctx) => {
				return {
					status: 200,
					body: {
						hello: "world",
					},
				};
			},
		);
		const endpoints = {
			endpoint,
		};
		const client = createClient<typeof endpoints>({
			baseURL: "http://localhost:3000",
		});
		expectTypeOf<Parameters<typeof client>[0]>().toMatchTypeOf<"@post/test">();
	});
});



================================================
File: src/client.ts
================================================
import { type BetterFetchOption, type BetterFetchResponse, createFetch } from "@better-fetch/fetch";
import type { Router } from "./router";
import type { HasRequiredKeys, Prettify, UnionToIntersection } from "./helper";
import type { Endpoint } from "./endpoint";

type HasRequired<
	T extends {
		body?: any;
		query?: any;
		params?: any;
	},
> = HasRequiredKeys<T> extends true
	? HasRequiredKeys<T["body"]> extends false
		? HasRequiredKeys<T["query"]> extends false
			? HasRequiredKeys<T["params"]> extends false
				? false
				: true
			: true
		: true
	: true;

type InferContext<T> = T extends (ctx: infer Ctx) => any
	? Ctx extends object
		? Ctx
		: never
	: never;

export interface ClientOptions extends BetterFetchOption {
	baseURL: string;
}

type WithRequired<T, K> = T & {
	[P in K extends string ? K : never]-?: T[P extends keyof T ? P : never];
};

export type RequiredOptionKeys<
	C extends {
		body?: any;
		query?: any;
		params?: any;
	},
> = (undefined extends C["body"]
	? {}
	: {
			body: true;
		}) &
	(undefined extends C["query"]
		? {}
		: {
				query: true;
			}) &
	(undefined extends C["params"]
		? {}
		: {
				params: true;
			});

export const createClient = <R extends Router | Router["endpoints"]>(options: ClientOptions) => {
	const fetch = createFetch(options);
	type API = R extends { endpoints: Record<string, Endpoint> } ? R["endpoints"] : R;
	type Options = API extends {
		[key: string]: infer T;
	}
		? T extends Endpoint
			? {
					[key in T["options"]["method"] extends "GET"
						? T["path"]
						: `@${T["options"]["method"] extends string ? Lowercase<T["options"]["method"]> : never}${T["path"]}`]: T;
				}
			: {}
		: {};

	type O = Prettify<UnionToIntersection<Options>>;
	return async <OPT extends O, K extends keyof OPT, C extends InferContext<OPT[K]>>(
		path: K,
		...options: HasRequired<C> extends true
			? [
					WithRequired<
						BetterFetchOption<C["body"], C["query"], C["params"]>,
						keyof RequiredOptionKeys<C>
					>,
				]
			: [BetterFetchOption<C["body"], C["query"], C["params"]>?]
	): Promise<
		BetterFetchResponse<Awaited<ReturnType<OPT[K] extends Endpoint ? OPT[K] : never>>>
	> => {
		return (await fetch(path as string, {
			...options[0],
		})) as any;
	};
};



================================================
File: src/context.ts
================================================
import type { EndpointOptions } from "./endpoint";
import { _statusCode, APIError, type Status } from "./error";
import type {
	InferParamPath,
	InferParamWildCard,
	Input,
	IsEmptyObject,
	Prettify,
	UnionToIntersection,
} from "./helper";
import type { Middleware, MiddlewareOptions } from "./middleware";
import { runValidation } from "./validator";
import {
	getCookieKey,
	parseCookies,
	serializeCookie,
	serializeSignedCookie,
	type CookieOptions,
	type CookiePrefixOptions,
} from "./cookies";
import { getCryptoKey, verifySignature } from "./crypto";
import type { StandardSchemaV1 } from "./standard-schema";

export type HTTPMethod = "GET" | "POST" | "PUT" | "DELETE" | "PATCH";
export type Method = HTTPMethod | "*";

export type InferBodyInput<Options extends EndpointOptions | MiddlewareOptions> =
	Options["metadata"] extends {
		$Infer: {
			body: infer Body;
		};
	}
		? Body
		: Options["body"] extends StandardSchemaV1
			? StandardSchemaV1.InferInput<Options["body"]>
			: undefined;

export type InferBody<Options extends EndpointOptions | MiddlewareOptions> =
	Options["metadata"] extends {
		$Infer: {
			body: infer Body;
		};
	}
		? Body
		: Options["body"] extends StandardSchemaV1
			? StandardSchemaV1.InferOutput<Options["body"]>
			: any;

export type InferQueryInput<Options extends EndpointOptions | MiddlewareOptions> =
	Options["metadata"] extends {
		$Infer: {
			query: infer Query;
		};
	}
		? Query
		: Options["query"] extends StandardSchemaV1
			? StandardSchemaV1.InferInput<Options["query"]>
			: Record<string, any> | undefined;

export type InferQuery<Options extends EndpointOptions | MiddlewareOptions> =
	Options["metadata"] extends {
		$Infer: {
			query: infer Query;
		};
	}
		? Query
		: Options["query"] extends StandardSchemaV1
			? StandardSchemaV1.InferOutput<Options["query"]>
			: Record<string, any> | undefined;

export type InferMethod<Options extends EndpointOptions> = Options["method"] extends Array<Method>
	? Options["method"][number]
	: Options["method"] extends "*"
		? HTTPMethod
		: Options["method"];

export type InferInputMethod<Options extends EndpointOptions> =
	Options["method"] extends Array<Method>
		? Options["method"][number]
		: Options["method"] extends "*"
			? HTTPMethod
			: Options["method"] | undefined;

export type InferParam<Path extends string> = IsEmptyObject<
	InferParamPath<Path> & InferParamWildCard<Path>
> extends true
	? Record<string, any> | undefined
	: Prettify<InferParamPath<Path> & InferParamWildCard<Path>>;

export type InferRequest<Option extends EndpointOptions | MiddlewareOptions> =
	Option["requireRequest"] extends true ? Request : Request | undefined;

export type InferHeaders<Option extends EndpointOptions | MiddlewareOptions> =
	Option["requireHeaders"] extends true ? Headers : Headers | undefined;

export type InferHeadersInput<Option extends EndpointOptions | MiddlewareOptions> =
	Option["requireHeaders"] extends true ? HeadersInit : HeadersInit | undefined;

export type InferUse<Opts extends EndpointOptions["use"]> = Opts extends Middleware[]
	? UnionToIntersection<Awaited<ReturnType<Opts[number]>>>
	: {};

export type InferMiddlewareBody<Options extends MiddlewareOptions> =
	Options["body"] extends StandardSchemaV1<infer T> ? T : any;

export type InferMiddlewareQuery<Options extends MiddlewareOptions> =
	Options["query"] extends StandardSchemaV1<infer T> ? T : Record<string, any> | undefined;

export type InputContext<Path extends string, Options extends EndpointOptions> = Input<{
	/**
	 * Payload
	 */
	body: InferBodyInput<Options>;
	/**
	 * Request Method
	 */
	method: InferInputMethod<Options>;
	/**
	 * Query Params
	 */
	query: InferQueryInput<Options>;
	/**
	 * Dynamic Params
	 */
	params: InferParam<Path>;
	/**
	 * Request Object
	 */
	request: InferRequest<Options>;
	/**
	 * Headers
	 */
	headers: InferHeadersInput<Options>;
	/**
	 * Return a `Response` object
	 */
	asResponse?: boolean;
	/**
	 * include headers on the return
	 */
	returnHeaders?: boolean;
	/**
	 * Middlewares to use
	 */
	use?: Middleware[];
	/**
	 * Customize the path
	 */
	path?: string;
}>;

export const createInternalContext = async (
	context: InputContext<any, any>,
	{
		options,
		path,
	}: {
		options: EndpointOptions;
		path: string;
	},
) => {
	const headers = new Headers();
	const { data, error } = await runValidation(options, context);
	if (error) {
		throw new APIError(400, {
			message: error.message,
			code: "VALIDATION_ERROR",
		});
	}
	const requestHeaders: Headers | null =
		"headers" in context
			? context.headers instanceof Headers
				? context.headers
				: new Headers(context.headers)
			: "request" in context && context.request instanceof Request
				? context.request.headers
				: null;
	const requestCookies = requestHeaders?.get("cookie");
	const parsedCookies = requestCookies ? parseCookies(requestCookies) : undefined;
	const internalContext = {
		...context,
		body: data.body,
		query: data.query,
		path: context.path || path,
		context: "context" in context && context.context ? context.context : {},
		returned: undefined as any,
		headers: context?.headers,
		request: context?.request,
		params: "params" in context ? context.params : undefined,
		method: context.method,
		setHeader: (key: string, value: string) => {
			headers.set(key, value);
		},
		getHeader: (key: string) => {
			if (!requestHeaders) return null;
			return requestHeaders.get(key);
		},
		getCookie: (key: string, prefix?: CookiePrefixOptions) => {
			const finalKey = getCookieKey(key, prefix);
			if (!finalKey) {
				return null;
			}
			return parsedCookies?.get(finalKey) || null;
		},
		getSignedCookie: async (key: string, secret: string, prefix?: CookiePrefixOptions) => {
			const finalKey = getCookieKey(key, prefix);
			if (!finalKey) {
				return null;
			}
			const value = parsedCookies?.get(finalKey);
			if (!value) {
				return null;
			}
			const signatureStartPos = value.lastIndexOf(".");
			if (signatureStartPos < 1) {
				return null;
			}
			const signedValue = value.substring(0, signatureStartPos);
			const signature = value.substring(signatureStartPos + 1);
			if (signature.length !== 44 || !signature.endsWith("=")) {
				return null;
			}
			const secretKey = await getCryptoKey(secret);
			const isVerified = await verifySignature(signature, signedValue, secretKey);
			return isVerified ? signedValue : false;
		},
		setCookie: (key: string, value: string, options?: CookieOptions) => {
			const cookie = serializeCookie(key, value, options);
			headers.append("set-cookie", cookie);
			return cookie;
		},
		setSignedCookie: async (
			key: string,
			value: string,
			secret: string,
			options?: CookieOptions,
		) => {
			const cookie = await serializeSignedCookie(key, value, secret, options);
			headers.append("set-cookie", cookie);
			return cookie;
		},
		redirect: (url: string) => {
			headers.set("location", url);
			return new APIError("FOUND", undefined, headers);
		},
		error: (
			status: keyof typeof _statusCode | Status,
			body?:
				| {
						message?: string;
						code?: string;
				  }
				| undefined,
			headers?: HeadersInit,
		) => {
			return new APIError(status, body, headers);
		},
		json: (
			json: Record<string, any>,
			routerResponse?:
				| {
						status?: number;
						headers?: Record<string, string>;
						response?: Response;
						body?: Record<string, any>;
				  }
				| Response,
		) => {
			if (!context.asResponse) {
				return json;
			}
			return {
				body: routerResponse?.body || json,
				routerResponse,
				_flag: "json",
			};
		},
		responseHeaders: headers,
	};
	//if context was shimmed through the input we want to apply it
	for (const middleware of options.use || []) {
		const response = (await middleware({
			...internalContext,
			returnHeaders: true,
			asResponse: false,
		})) as {
			response?: any;
			headers?: Headers;
		};
		if (response.response) {
			Object.assign(internalContext.context, response.response);
		}
		/**
		 * Apply headers from the middleware to the endpoint headers
		 */
		if (response.headers) {
			response.headers.forEach((value, key) => {
				internalContext.responseHeaders.set(key, value);
			});
		}
	}
	return internalContext;
};



================================================
File: src/cookies.test.ts
================================================
import { describe, expect, it } from "vitest";
import { createEndpoint } from "./endpoint";
import { z } from "zod";
import { signCookieValue } from "./crypto";
import { parseCookies } from "./cookies";

describe("parseCookies", () => {
	it("should parse cookies", () => {
		const cookies = parseCookies("test=test; test2=test 2");
		expect(cookies.get("test")).toBe("test");
		expect(cookies.get("test2")).toBe("test 2");
	});

	it("should parse cookies with encoded values", () => {
		const cookies = parseCookies("test=test; test2=test%202");
		expect(cookies.get("test")).toBe("test");
		expect(cookies.get("test2")).toBe("test 2");
	});
});

describe("get-cookies", () => {
	it("should get cookies", async () => {
		const endpoint = createEndpoint(
			"/",
			{
				method: "POST",
				body: z.object({
					cookieName: z.string(),
				}),
				requireHeaders: true,
			},
			async (c) => {
				return c.getCookie(c.body.cookieName);
			},
		);
		const response = await endpoint({
			body: {
				cookieName: "test",
			},
			headers: {
				cookie: "test=test",
			},
		});
		expect(response).toBe("test");
	});

	it("should get signed cookies", async () => {
		const secret = "test";
		const endpoint = createEndpoint(
			"/",
			{
				method: "POST",
				body: z.object({
					cookieName: z.string(),
				}),
				requireHeaders: true,
			},
			async (c) => {
				return c.getSignedCookie(c.body.cookieName, secret);
			},
		);
		const response = await endpoint({
			body: {
				cookieName: "test",
			},
			headers: {
				cookie: `test=${await signCookieValue("test", secret)}`,
			},
		});
		expect(response).toBe("test");
	});

	it("should return null if signature is invalid", async () => {
		const secret = "test";
		const endpoint = createEndpoint(
			"/",
			{
				method: "POST",
				body: z.object({
					cookieName: z.string(),
				}),
				requireHeaders: true,
			},
			async (c) => {
				return c.getSignedCookie(c.body.cookieName, secret);
			},
		);
		const response = await endpoint({
			body: {
				cookieName: "test",
			},
			headers: {
				cookie: `test=invalid_signature`,
			},
		});
		expect(response).toBe(null);
	});

	it("should return false if secret is invalid", async () => {
		const secret = "test";
		const endpoint = createEndpoint(
			"/",
			{
				method: "POST",
				body: z.object({
					cookieName: z.string(),
				}),
				requireHeaders: true,
			},
			async (c) => {
				return c.getSignedCookie(c.body.cookieName, "invalid_secret");
			},
		);
		const response = await endpoint({
			body: {
				cookieName: "test",
			},
			headers: {
				cookie: `test=${await signCookieValue("test", secret)}`,
			},
		});
		expect(response).toBe(false);
	});
});

describe("set-cookies", () => {
	it("should set cookie", async () => {
		const endpoint = createEndpoint(
			"/",
			{
				method: "POST",
			},
			async (c) => {
				c.setCookie("test", "test");
			},
		);
		const response = await endpoint({
			returnHeaders: true,
		});
		expect(response.headers.get("set-cookie")).toBe("test=test");
	});

	it("should set multiple cookies", async () => {
		const endpoint = createEndpoint(
			"/",
			{
				method: "POST",
			},
			async (c) => {
				c.setCookie("test", "test");
				c.setCookie("test2", "test2");
				c.setCookie("test3", "test3");
			},
		);
		const response = await endpoint({
			returnHeaders: true,
		});
		expect(response.headers.get("set-cookie")).toBe("test=test, test2=test2, test3=test3");
	});

	it("should apply options", async () => {
		const endpoint = createEndpoint(
			"/",
			{
				method: "POST",
			},
			async (c) => {
				c.setCookie("test", "test", {
					secure: true,
					httpOnly: true,
					path: "/",
				});
			},
		);
		const response = await endpoint({
			returnHeaders: true,
		});

		expect(response.headers.get("Set-Cookie")).toBe("test=test; Path=/; HttpOnly; Secure");
	});

	it("should apply multiple cookies with options", async () => {
		const endpoint = createEndpoint(
			"/",
			{
				method: "POST",
			},
			async (c) => {
				c.setCookie("test", "test", {
					secure: true,
					httpOnly: true,
					path: "/",
				});
				c.setCookie("test2", "test2", {
					secure: true,
					httpOnly: true,
					path: "/",
				});
			},
		);
		const response = await endpoint({
			returnHeaders: true,
		});
		expect(response.headers.get("Set-Cookie")).toBe(
			"test=test; Path=/; HttpOnly; Secure, test2=test2; Path=/; HttpOnly; Secure",
		);
	});

	it("should set signed cookie", async () => {
		const endpoint = createEndpoint(
			"/",
			{
				method: "POST",
			},
			async (c) => {
				await c.setSignedCookie("test", "test", "test");
			},
		);
		const response = await endpoint({
			returnHeaders: true,
		});
		const setCookie = response.headers.get("set-cookie");
		const signature = setCookie?.split(".")[1];
		expect(setCookie).toContain("test=test.");
		expect(signature?.length).toBeGreaterThan(10);
	});

	it("should properly sign cookies", async () => {
		const endpoint = createEndpoint(
			"/",
			{
				method: "POST",
			},
			async (c) => {
				await c.setSignedCookie("test", "test", "test");
			},
		);
		const response = await endpoint({
			returnHeaders: true,
		});
		const setCookie = response.headers.get("set-cookie");
		const endpoint2 = createEndpoint(
			"/",
			{
				method: "POST",
				requireHeaders: true,
			},
			async (c) => {
				return await c.getSignedCookie("test", "test");
			},
		);
		const response2 = await endpoint2({
			headers: {
				cookie: setCookie!,
			},
		});
		expect(response2).toBe("test");
	});
});



================================================
File: src/cookies.ts
================================================
import { signCookieValue } from "./crypto";
import { tryDecode } from "./utils";

export type CookiePrefixOptions = "host" | "secure";

export type CookieOptions = {
	/**
	 * Domain of the cookie
	 *
	 * The Domain attribute specifies which server can receive a cookie. If specified, cookies are
	 * available on the specified server and its subdomains. If the it is not
	 * specified, the cookies are available on the server that sets it but not on
	 * its subdomains.
	 *
	 * @example
	 * `domain: "example.com"`
	 */
	domain?: string;
	/**
	 * A lifetime of a cookie. Permanent cookies are deleted after the date specified in the
	 * Expires attribute:
	 *
	 * Expires has been available for longer than Max-Age, however Max-Age is less error-prone, and
	 * takes precedence when both are set. The rationale behind this is that when you set an
	 * Expires date and time, they're relative to the client the cookie is being set on. If the
	 * server is set to a different time, this could cause errors
	 */
	expires?: Date;
	/**
	 * Forbids JavaScript from accessing the cookie, for example, through the Document.cookie
	 * property. Note that a cookie that has been created with HttpOnly will still be sent with
	 * JavaScript-initiated requests, for example, when calling XMLHttpRequest.send() or fetch().
	 * This mitigates attacks against cross-site scripting
	 */
	httpOnly?: boolean;
	/**
	 * Indicates the number of seconds until the cookie expires. A zero or negative number will
	 * expire the cookie immediately. If both Expires and Max-Age are set, Max-Age has precedence.
	 *
	 * @example 604800 - 7 days
	 */
	maxAge?: number;
	/**
	 * Indicates the path that must exist in the requested URL for the browser to send the Cookie
	 * header.
	 *
	 * @example
	 * "/docs"
	 * // -> the request paths /docs, /docs/, /docs/Web/, and /docs/Web/HTTP will all match. the request paths /, /fr/docs will not match.
	 */
	path?: string;
	/**
	 * Indicates that the cookie is sent to the server only when a request is made with the https:
	 * scheme (except on localhost), and therefore, is more resistant to man-in-the-middle attacks.
	 */
	secure?: boolean;
	/**
	 * Controls whether or not a cookie is sent with cross-site requests, providing some protection
	 * against cross-site request forgery attacks (CSRF).
	 *
	 * Strict -  Means that the browser sends the cookie only for same-site requests, that is,
	 * requests originating from the same site that set the cookie. If a request originates from a
	 * different domain or scheme (even with the same domain), no cookies with the SameSite=Strict
	 * attribute are sent.
	 *
	 * Lax - Means that the cookie is not sent on cross-site requests, such as on requests to load
	 * images or frames, but is sent when a user is navigating to the origin site from an external
	 * site (for example, when following a link). This is the default behavior if the SameSite
	 * attribute is not specified.
	 *
	 * None - Means that the browser sends the cookie with both cross-site and same-site requests.
	 * The Secure attribute must also be set when setting this value.
	 */
	sameSite?: "Strict" | "Lax" | "None" | "strict" | "lax" | "none";
	/**
	 * Indicates that the cookie should be stored using partitioned storage. Note that if this is
	 * set, the Secure directive must also be set.
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Web/Privacy/Privacy_sandbox/Partitioned_cookies
	 */
	partitioned?: boolean;
	/**
	 * Cooke Prefix
	 *
	 * - secure: `__Secure-` -> `__Secure-cookie-name`
	 * - host: `__Host-` -> `__Host-cookie-name`
	 *
	 * `secure` must be set to true to use prefixes
	 */
	prefix?: CookiePrefixOptions;
};

export const getCookieKey = (key: string, prefix?: CookiePrefixOptions) => {
	let finalKey = key;
	if (prefix) {
		if (prefix === "secure") {
			finalKey = "__Secure-" + key;
		} else if (prefix === "host") {
			finalKey = "__Host-" + key;
		} else {
			return undefined;
		}
	}
	return finalKey;
};

/**
 * Parse an HTTP Cookie header string and returning an object of all cookie
 * name-value pairs.
 *
 * Inspired by https://github.com/unjs/cookie-es/blob/main/src/cookie/parse.ts
 *
 * @param str the string representing a `Cookie` header value
 */
export function parseCookies(str: string) {
	if (typeof str !== "string") {
		throw new TypeError("argument str must be a string");
	}

	const cookies: Map<string, string> = new Map();

	let index = 0;
	while (index < str.length) {
		const eqIdx = str.indexOf("=", index);

		if (eqIdx === -1) {
			break;
		}

		let endIdx = str.indexOf(";", index);

		if (endIdx === -1) {
			endIdx = str.length;
		} else if (endIdx < eqIdx) {
			index = str.lastIndexOf(";", eqIdx - 1) + 1;
			continue;
		}

		const key = str.slice(index, eqIdx).trim();
		if (!cookies.has(key)) {
			let val = str.slice(eqIdx + 1, endIdx).trim();
			if (val.codePointAt(0) === 0x22) {
				val = val.slice(1, -1);
			}
			cookies.set(key, tryDecode(val));
		}

		index = endIdx + 1;
	}

	return cookies;
}

const _serialize = (key: string, value: string, opt: CookieOptions = {}) => {
	let cookie: string;

	if (opt?.prefix === "secure") {
		cookie = `${`__Secure-${key}`}=${value}`;
	} else if (opt?.prefix === "host") {
		cookie = `${`__Host-${key}`}=${value}`;
	} else {
		cookie = `${key}=${value}`;
	}

	if (key.startsWith("__Secure-") && !opt.secure) {
		opt.secure = true;
	}

	if (key.startsWith("__Host-")) {
		if (!opt.secure) {
			opt.secure = true;
		}

		if (opt.path !== "/") {
			opt.path = "/";
		}

		if (opt.domain) {
			opt.domain = undefined;
		}
	}

	if (opt && typeof opt.maxAge === "number" && opt.maxAge >= 0) {
		if (opt.maxAge > 34560000) {
			throw new Error(
				"Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration.",
			);
		}
		cookie += `; Max-Age=${Math.floor(opt.maxAge)}`;
	}

	if (opt.domain && opt.prefix !== "host") {
		cookie += `; Domain=${opt.domain}`;
	}

	if (opt.path) {
		cookie += `; Path=${opt.path}`;
	}

	if (opt.expires) {
		if (opt.expires.getTime() - Date.now() > 34560000_000) {
			throw new Error(
				"Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future.",
			);
		}
		cookie += `; Expires=${opt.expires.toUTCString()}`;
	}

	if (opt.httpOnly) {
		cookie += "; HttpOnly";
	}

	if (opt.secure) {
		cookie += "; Secure";
	}

	if (opt.sameSite) {
		cookie += `; SameSite=${opt.sameSite.charAt(0).toUpperCase() + opt.sameSite.slice(1)}`;
	}

	if (opt.partitioned) {
		if (!opt.secure) {
			opt.secure = true;
		}
		cookie += "; Partitioned";
	}

	return cookie;
};

export const serializeCookie = (key: string, value: string, opt?: CookieOptions) => {
	value = encodeURIComponent(value);
	return _serialize(key, value, opt);
};

export const serializeSignedCookie = async (
	key: string,
	value: string,
	secret: string,
	opt?: CookieOptions,
) => {
	value = await signCookieValue(value, secret);
	return _serialize(key, value, opt);
};



================================================
File: src/crypto.ts
================================================
import { subtle } from "uncrypto";

const algorithm = { name: "HMAC", hash: "SHA-256" };

export const getCryptoKey = async (secret: string | BufferSource) => {
	const secretBuf = typeof secret === "string" ? new TextEncoder().encode(secret) : secret;
	return await subtle.importKey("raw", secretBuf, algorithm, false, ["sign", "verify"]);
};

export const verifySignature = async (
	base64Signature: string,
	value: string,
	secret: CryptoKey,
): Promise<boolean> => {
	try {
		const signatureBinStr = atob(base64Signature);
		const signature = new Uint8Array(signatureBinStr.length);
		for (let i = 0, len = signatureBinStr.length; i < len; i++) {
			signature[i] = signatureBinStr.charCodeAt(i);
		}
		return await subtle.verify(algorithm, secret, signature, new TextEncoder().encode(value));
	} catch (e) {
		return false;
	}
};

const makeSignature = async (value: string, secret: string | BufferSource): Promise<string> => {
	const key = await getCryptoKey(secret);
	const signature = await subtle.sign(algorithm.name, key, new TextEncoder().encode(value));
	// the returned base64 encoded signature will always be 44 characters long and end with one or two equal signs
	return btoa(String.fromCharCode(...new Uint8Array(signature)));
};

export const signCookieValue = async (value: string, secret: string | BufferSource) => {
	const signature = await makeSignature(value, secret);
	value = `${value}.${signature}`;
	value = encodeURIComponent(value);
	return value;
};



================================================
File: src/endpoint.test.ts
================================================
import { describe, expect, expectTypeOf, it } from "vitest";
import { createEndpoint } from "./endpoint";
import { z } from "zod";
import { APIError } from "./error";
import { createMiddleware } from "./middleware";
import * as v from "valibot";

describe("validation", (it) => {
	it("should validate body and throw validation error", async () => {
		const endpoint = createEndpoint(
			"/test",
			{
				method: "GET",
				body: v.object({
					name: v.string(),
				}),
			},
			async (ctx) => {
				ctx.body;
				ctx.headers;
				return ctx.body;
			},
		);

		await expect(
			endpoint({
				//@ts-expect-error
				body: { name: 1 },
			}),
		).rejects.toThrowError("Invalid body parameters");
	});

	it("should validate query and throw validation error", async () => {
		const endpoint = createEndpoint(
			"/test",
			{
				method: "GET",
				query: v.object({
					name: v.string(),
				}),
			},
			async (ctx) => {
				return ctx.query;
			},
		);

		await expect(
			endpoint({
				//@ts-expect-error
				query: { name: 1 },
			}),
		).rejects.toThrowError(`Invalid query parameters`);
	});

	it("should validate the body and return the body", async () => {
		const endpoint = createEndpoint(
			"/test",
			{
				method: "GET",
				body: z.object({
					name: z.string().transform((val) => `${val}-validated`),
				}),
			},
			async (ctx) => {
				return ctx.body;
			},
		);
		const response = await endpoint({
			body: {
				name: "test",
			},
		});

		expect(response.name).toBe("test-validated");
	});

	it("should validate the body and return the query", async () => {
		const endpoint = createEndpoint(
			"/test",
			{
				method: "GET",
				query: z.object({
					name: z.string().transform((val) => `${val}-validated`),
				}),
			},
			async (ctx) => {
				return ctx.query;
			},
		);
		const response = await endpoint({
			query: {
				name: "test",
			},
		});
		expect(response.name).toBe("test-validated");
	});
});

describe("types", async () => {
	it("body", async () => {
		createEndpoint(
			"/test",
			{
				method: "GET",
				body: z.object({
					name: z.string(),
				}),
			},
			async (ctx) => {
				expectTypeOf(ctx.body).toEqualTypeOf<{ name: string }>();
			},
		);

		createEndpoint(
			"/test",
			{
				method: "GET",
				body: z.object({
					name: z.string().optional(),
				}),
			},
			async (ctx) => {
				expectTypeOf(ctx.body).toEqualTypeOf<{ name?: string }>();
			},
		);

		createEndpoint(
			"/test",
			{
				method: "GET",
				body: z
					.object({
						name: z.string(),
					})
					.optional(),
			},
			async (ctx) => {
				expectTypeOf(ctx.body).toEqualTypeOf<{ name: string } | undefined>();
			},
		);

		createEndpoint(
			"/path",
			{
				method: "POST",
				body: z.record(z.string()),
				metadata: {
					$Infer: {
						body: {} as {
							hello: "world";
						},
					},
				},
			},
			async (c) => {
				expectTypeOf(c.body).toMatchTypeOf<{
					hello: "world";
				}>();
			},
		);
	});

	it("query", async () => {
		createEndpoint(
			"/test",
			{
				method: "GET",
				query: z.object({
					name: z.string(),
				}),
			},
			async (ctx) => {
				expectTypeOf(ctx.query).toEqualTypeOf<{ name: string }>();
			},
		);

		createEndpoint(
			"/test",
			{
				method: "GET",
				query: z.object({
					name: z.string().optional(),
				}),
			},
			async (ctx) => {
				expectTypeOf(ctx.query).toEqualTypeOf<{ name?: string }>();
			},
		);

		createEndpoint(
			"/test",
			{
				method: "GET",
				query: z.optional(
					z.object({
						name: z.string(),
					}),
				),
			},
			async (ctx) => {
				expectTypeOf(ctx.query).toEqualTypeOf<{ name: string } | undefined>();
			},
		);

		createEndpoint(
			"/path",
			{
				method: "POST",
				body: z.record(z.string()),
				metadata: {
					$Infer: {
						query: {} as {
							hello: "world";
						},
					},
				},
			},
			async (c) => {
				expectTypeOf(c.query).toMatchTypeOf<{
					hello: "world";
				}>();
			},
		);
	});

	it("params", async () => {
		createEndpoint(
			"/:id",
			{
				method: "GET",
			},
			async (ctx) => {
				expectTypeOf(ctx.params).toEqualTypeOf<{ id: string }>();
			},
		);

		createEndpoint(
			"/leading-path/:id",
			{
				method: "GET",
			},
			async (ctx) => {
				expectTypeOf(ctx.params).toEqualTypeOf<{ id: string }>();
			},
		);

		createEndpoint(
			"/leading-path/:id/:name",
			{
				method: "GET",
			},
			async (ctx) => {
				ctx.params;
				expectTypeOf(ctx.params).toEqualTypeOf<{ id: string; name: string }>();
			},
		);
	});

	it("wildcard params", async () => {
		createEndpoint(
			"/api/*",
			{
				method: "GET",
			},
			async (ctx) => {
				expectTypeOf(ctx.params).toEqualTypeOf<{ _: string }>();
			},
		);

		createEndpoint(
			"/api/:id/*",
			{
				method: "GET",
			},
			async (ctx) => {
				expectTypeOf(ctx.params).toEqualTypeOf<{ _: string; id: string }>();
			},
		);
	});

	it("method", async () => {
		createEndpoint(
			"/test",
			{
				method: "GET",
			},
			async (ctx) => {
				expectTypeOf(ctx.method).toEqualTypeOf<"GET">();
			},
		);

		const endpoint = createEndpoint(
			"/test",
			{
				method: ["POST", "GET"],
			},
			async (ctx) => {
				expectTypeOf(ctx.method).toEqualTypeOf<"POST" | "GET">();
			},
		);
		//@ts-expect-error - method should be required
		endpoint({});
		const wildCardMethodEndpoint = createEndpoint(
			"/test",
			{
				method: "*",
			},
			async (ctx) => {
				expectTypeOf(ctx.method).toEqualTypeOf<
					"POST" | "GET" | "DELETE" | "PUT" | "PATCH"
				>();
			},
		);
		//@ts-expect-error -
		wildCardMethodEndpoint({});
	});
	it("response", async () => {
		const endpoint1 = createEndpoint(
			"/test",
			{
				method: "GET",
			},
			async (ctx) => {
				return { name: "test" };
			},
		);
		const jsonResponse1 = await endpoint1();
		expectTypeOf(jsonResponse1).toEqualTypeOf<{ name: string }>();
		const objResponse1 = await endpoint1({ asResponse: true });
		expectTypeOf(objResponse1).toEqualTypeOf<Response>();
	});
});

describe("response", () => {
	describe("flat", () => {
		it("should return primitive values", async () => {
			for (const value of [1, "hello", true]) {
				const endpoint = createEndpoint(
					"/path",
					{
						method: "POST",
					},
					async (ctx) => {
						return value;
					},
				);
				const response = await endpoint();
				expect(response).toBe(value);
			}
		});
	});

	describe("json", () => {
		it("should return a js object response on direct call", async () => {
			const endpoint = createEndpoint(
				"/path",
				{
					method: "POST",
				},
				async (ctx) => {
					return ctx.json({ test: "response" });
				},
			);
			const response = await endpoint();
			expect(response).toMatchObject({
				test: "response",
			});
		});
	});

	describe("as-response", () => {
		it("should return a response object", async () => {
			const responses = [
				{
					type: "number",
					value: 1,
				},
				{
					type: "string",
					value: "hello world!",
				},
				{
					type: "object",
					value: {
						hello: "world",
					},
				},
				{
					type: "object",
					value: ["1", "2", "3"],
				},
			];
			for (const value of responses) {
				const endpoint = createEndpoint(
					"/path",
					{
						method: "POST",
					},
					async () => {
						return value.value;
					},
				);
				const response = await endpoint({
					asResponse: true,
				});
				const body = await response.text();
				if (value.type !== "object") {
					expect(body).toBe(value.value.toString());
				} else {
					expect(body).toMatch(JSON.stringify(value.value));
				}
			}
		});
	});

	describe("redirect", () => {
		it("should return redirect response", async () => {
			const endpoint = createEndpoint(
				"/endpoint",
				{
					method: "POST",
				},
				async (c) => {
					return c.redirect("/");
				},
			);
			const response = await endpoint();
			expect(response).instanceOf(APIError);
			expect(response.status).toBe("FOUND");
			expect(response.statusCode).toBe(302);
		});
	});

	describe("set-headers", () => {
		it("should set headers", async () => {
			const endpoint = createEndpoint(
				"/endpoint",
				{
					method: "POST",
				},
				async (c) => {
					c.setHeader("hello", "world");
				},
			);
			const response = await endpoint({
				asResponse: true,
			});
			expect(response.headers.get("hello")).toBe("world");

			const response2 = await endpoint({
				returnHeaders: true,
			});
			expect(response2.headers.get("hello")).toBe("world");
		});
	});

	describe("API Error", () => {
		it("should throw API Error", async () => {
			const endpoint = createEndpoint(
				"/endpoint",
				{
					method: "POST",
				},
				async (c) => {
					throw c.error("NOT_FOUND");
				},
			);
			await expect(endpoint()).rejects.toThrowError(APIError);
		});

		it("should return error Response", async () => {
			const endpoint = createEndpoint(
				"/endpoint",
				{
					method: "POST",
				},
				async (c) => {
					throw c.error("NOT_FOUND");
				},
			);
			const response = await endpoint({
				asResponse: true,
			});
			expect(response.status).toBe(404);
		});

		it("should return error Response with it's body", async () => {
			const endpoint = createEndpoint(
				"/endpoint",
				{
					method: "POST",
				},
				async (c) => {
					throw c.error("BAD_REQUEST", {
						message: "error message",
					});
				},
			);
			const response = await endpoint({
				asResponse: true,
			});
			const body = await response.json();
			expect(response.status).toBe(400);
			expect(body).toMatchObject({
				message: "error message",
			});
		});
	});
	describe("json", async () => {
		it("should return the json directly", async () => {
			const endpoint = createEndpoint(
				"/",
				{
					method: "GET",
				},
				async (c) => {
					return c.json(
						{ name: "hello" },
						new Response(
							JSON.stringify({
								client: "hello",
							}),
						),
					);
				},
			);
			const response = await endpoint();
			expect(response).toMatchObject({
				name: "hello",
			});
		});
	});
});

describe("creator", () => {
	it("should use creator context", async () => {
		const creator = createEndpoint.create({
			use: [
				createMiddleware(async () => {
					return {
						hello: "world",
					};
				}),
			],
		});
		const endpoint = creator(
			"/path",
			{
				method: "POST",
			},
			async (c) => {
				return c.context;
			},
		);
		const response = await endpoint();
		expect(response).toMatchObject({
			hello: "world",
		});
	});

	it("should be able to combine with endpoint middleware", async () => {
		const creator = createEndpoint.create({
			use: [
				createMiddleware(async () => {
					return {
						hello: "world",
					};
				}),
			],
		});
		const endpoint = creator(
			"/path",
			{
				method: "POST",
				use: [
					createMiddleware(async () => {
						return {
							test: "payload",
						};
					}),
				],
			},
			async (c) => {
				return c.context;
			},
		);
		const response = await endpoint();
		expect(response).toMatchObject({
			hello: "world",
			test: "payload",
		});
	});
});

const c = createEndpoint(
	"/",
	{
		method: "GET",
	},
	async () => {
		return {
			hello: "world",
		};
	},
);



================================================
File: src/endpoint.ts
================================================
import type { HasRequiredKeys, Prettify } from "./helper";
import { toResponse } from "./to-response";
import { type Middleware } from "./middleware";
import {
	createInternalContext,
	type InferBody,
	type InferHeaders,
	type InferMethod,
	type InferParam,
	type InferQuery,
	type InferRequest,
	type InferUse,
	type InputContext,
	type Method,
} from "./context";
import type { CookieOptions, CookiePrefixOptions } from "./cookies";
import { APIError, type _statusCode, type Status } from "./error";
import type { OpenAPIParameter, OpenAPISchemaType } from "./openapi";
import type { StandardSchemaV1 } from "./standard-schema";
import { isAPIError } from "./utils";

export interface EndpointOptions {
	/**
	 * Request Method
	 */
	method: Method | Method[];
	/**
	 * Body Schema
	 */
	body?: StandardSchemaV1;
	/**
	 * Query Schema
	 */
	query?: StandardSchemaV1;
	/**
	 * If true headers will be required to be passed in the context
	 */
	requireHeaders?: boolean;
	/**
	 * If true request object will be required
	 */
	requireRequest?: boolean;
	/**
	 * Clone the request object from the router
	 */
	cloneRequest?: boolean;
	/**
	 * Endpoint metadata
	 */
	metadata?: {
		/**
		 * Open API definition
		 */
		openapi?: {
			summary?: string;
			description?: string;
			tags?: string[];
			operationId?: string;
			parameters?: OpenAPIParameter[];
			requestBody?: {
				content: {
					"application/json": {
						schema: {
							type?: OpenAPISchemaType;
							properties?: Record<string, any>;
							required?: string[];
							$ref?: string;
						};
					};
				};
			};
			responses?: {
				[status: string]: {
					description: string;
					content?: {
						"application/json"?: {
							schema: {
								type?: OpenAPISchemaType;
								properties?: Record<string, any>;
								required?: string[];
								$ref?: string;
							};
						};
						"text/plain"?: {
							schema?: {
								type?: OpenAPISchemaType;
								properties?: Record<string, any>;
								required?: string[];
								$ref?: string;
							};
						};
						"text/html"?: {
							schema?: {
								type?: OpenAPISchemaType;
								properties?: Record<string, any>;
								required?: string[];
								$ref?: string;
							};
						};
					};
				};
			};
		};
		/**
		 * Infer body and query type from ts interface
		 *
		 * useful for generic and dynamic types
		 *
		 * @example
		 * ```ts
		 * const endpoint = createEndpoint("/path", {
		 * 		method: "POST",
		 * 		body: z.record(z.string()),
		 * 		$Infer: {
		 * 			body: {} as {
		 * 				type: InferTypeFromOptions<Option> // custom type inference
		 * 			}
		 * 		}
		 * 	}, async(ctx)=>{
		 * 		const body = ctx.body
		 * 	})
		 * ```
		 */
		$Infer?: {
			/**
			 * Body
			 */
			body?: any;
			/**
			 * Query
			 */
			query?: Record<string, any>;
		};
		/**
		 * If enabled, endpoint won't be exposed over a router
		 */
		SERVER_ONLY?: boolean;
		/**
		 * Extra metadata
		 */
		[key: string]: any;
	};
	/**
	 * List of middlewares to use
	 */
	use?: Middleware[];
}

export type EndpointContext<Path extends string, Options extends EndpointOptions, Context = {}> = {
	/**
	 * Method
	 *
	 * The request method
	 */
	method: InferMethod<Options>;
	/**
	 * Path
	 *
	 * The path of the endpoint
	 */
	path: Path;
	/**
	 * Body
	 *
	 * The body object will be the parsed JSON from the request and validated
	 * against the body schema if it exists.
	 */
	body: InferBody<Options>;
	/**
	 * Query
	 *
	 * The query object will be the parsed query string from the request
	 * and validated against the query schema if it exists
	 */
	query: InferQuery<Options>;
	/**
	 * Params
	 *
	 * If the path is `/user/:id` and the request is `/user/1` then the params will
	 * be `{ id: "1" }` and if the path includes a wildcard like `/user/*` then the
	 * params will be `{ _: "1" }` where `_` is the wildcard key. If the wildcard
	 * is named like `/user/**:name` then the params will be `{ name: string }`
	 */
	params: InferParam<Path>;
	/**
	 * Request object
	 *
	 * If `requireRequest` is set to true in the endpoint options this will be
	 * required
	 */
	request: InferRequest<Options>;
	/**
	 * Headers
	 *
	 * If `requireHeaders` is set to true in the endpoint options this will be
	 * required
	 */
	headers: InferHeaders<Options>;
	/**
	 * Set header
	 *
	 * If it's called outside of a request it will just be ignored.
	 */
	setHeader: (key: string, value: string) => void;
	/**
	 * Get header
	 *
	 * If it's called outside of a request it will just return null
	 *
	 * @param key  - The key of the header
	 * @returns
	 */
	getHeader: (key: string) => string | null;
	/**
	 * Get a cookie value from the request
	 *
	 * @param key - The key of the cookie
	 * @param prefix - The prefix of the cookie between `__Secure-` and `__Host-`
	 * @returns - The value of the cookie
	 */
	getCookie: (key: string, prefix?: CookiePrefixOptions) => string | null;
	/**
	 * Get a signed cookie value from the request
	 *
	 * @param key - The key of the cookie
	 * @param secret - The secret of the signed cookie
	 * @param prefix - The prefix of the cookie between `__Secure-` and `__Host-`
	 * @returns
	 */
	getSignedCookie: (
		key: string,
		secret: string,
		prefix?: CookiePrefixOptions,
	) => Promise<string | null>;
	/**
	 * Set a cookie value in the response
	 *
	 * @param key - The key of the cookie
	 * @param value - The value to set
	 * @param options - The options of the cookie
	 * @returns - The cookie string
	 */
	setCookie: (key: string, value: string, options?: CookieOptions) => string;
	/**
	 * Set signed cookie
	 *
	 * @param key - The key of the cookie
	 * @param value  - The value to set
	 * @param secret - The secret to sign the cookie with
	 * @param options - The options of the cookie
	 * @returns - The cookie string
	 */
	setSignedCookie: (
		key: string,
		value: string,
		secret: string,
		options?: CookieOptions,
	) => Promise<string>;
	/**
	 * JSON
	 *
	 * a helper function to create a JSON response with
	 * the correct headers
	 * and status code. If `asResponse` is set to true in
	 * the context then
	 * it will return a Response object instead of the
	 * JSON object.
	 *
	 * @param json - The JSON object to return
	 * @param routerResponse - The response object to
	 * return if `asResponse` is
	 * true in the context this will take precedence
	 */
	json: <R extends Record<string, any> | null>(
		json: R,
		routerResponse?:
			| {
					status?: number;
					headers?: Record<string, string>;
					response?: Response;
					body?: Record<string, string>;
			  }
			| Response,
	) => Promise<R>;
	/**
	 * Middleware context
	 */
	context: Prettify<Context & InferUse<Options["use"]>>;
	/**
	 * Redirect to a new URL
	 */
	redirect: (url: string) => APIError;
	/**
	 * Return error
	 */
	error: (
		status: keyof typeof _statusCode | Status,
		body?: {
			message?: string;
			code?: string;
		} & Record<string, any>,
		headers?: HeadersInit,
	) => APIError;
};

export const createEndpoint = <Path extends string, Options extends EndpointOptions, R>(
	path: Path,
	options: Options,
	handler: (context: EndpointContext<Path, Options>) => Promise<R>,
) => {
	type Context = InputContext<Path, Options>;
	const internalHandler = async <
		C extends HasRequiredKeys<Context> extends true ? [Context] : [Context?],
	>(
		...inputCtx: C
	) => {
		const context = (inputCtx[0] || {}) as InputContext<any, any>;
		const internalContext = await createInternalContext(context, {
			options,
			path,
		});
		const response = await handler(internalContext as any).catch((e) => {
			if (isAPIError(e) && context.asResponse) {
				return e;
			}
			throw e;
		});
		const headers = internalContext.responseHeaders;
		return (
			context.asResponse
				? toResponse(response, {
						headers,
					})
				: context.returnHeaders
					? {
							headers,
							response,
						}
					: response
		) as C extends [{ asResponse: true }]
			? Response
			: C extends [{ returnHeaders: true }]
				? {
						headers: Headers;
						response: R;
					}
				: R;
	};
	internalHandler.options = options;
	internalHandler.path = path;
	return internalHandler;
};

createEndpoint.create = <E extends { use?: Middleware[] }>(opts?: E) => {
	return <Path extends string, Opts extends EndpointOptions, R>(
		path: Path,
		options: Opts,
		handler: (ctx: EndpointContext<Path, Opts, InferUse<E["use"]>>) => Promise<R>,
	) => {
		return createEndpoint(
			path,
			{
				...options,
				use: [...(options?.use || []), ...(opts?.use || [])],
			},
			handler,
		);
	};
};

export type Endpoint<
	Path extends string = string,
	Options extends EndpointOptions = EndpointOptions,
	Handler extends (inputCtx: any) => Promise<any> = (inputCtx: any) => Promise<any>,
> = Handler & {
	options: Options;
	path: Path;
};



================================================
File: src/error.ts
================================================
export const _statusCode = {
	OK: 200,
	CREATED: 201,
	ACCEPTED: 202,
	NO_CONTENT: 204,
	MULTIPLE_CHOICES: 300,
	MOVED_PERMANENTLY: 301,
	FOUND: 302,
	SEE_OTHER: 303,
	NOT_MODIFIED: 304,
	TEMPORARY_REDIRECT: 307,
	BAD_REQUEST: 400,
	UNAUTHORIZED: 401,
	PAYMENT_REQUIRED: 402,
	FORBIDDEN: 403,
	NOT_FOUND: 404,
	METHOD_NOT_ALLOWED: 405,
	NOT_ACCEPTABLE: 406,
	PROXY_AUTHENTICATION_REQUIRED: 407,
	REQUEST_TIMEOUT: 408,
	CONFLICT: 409,
	GONE: 410,
	LENGTH_REQUIRED: 411,
	PRECONDITION_FAILED: 412,
	PAYLOAD_TOO_LARGE: 413,
	URI_TOO_LONG: 414,
	UNSUPPORTED_MEDIA_TYPE: 415,
	RANGE_NOT_SATISFIABLE: 416,
	EXPECTATION_FAILED: 417,
	"I'M_A_TEAPOT": 418,
	MISDIRECTED_REQUEST: 421,
	UNPROCESSABLE_ENTITY: 422,
	LOCKED: 423,
	FAILED_DEPENDENCY: 424,
	TOO_EARLY: 425,
	UPGRADE_REQUIRED: 426,
	PRECONDITION_REQUIRED: 428,
	TOO_MANY_REQUESTS: 429,
	REQUEST_HEADER_FIELDS_TOO_LARGE: 431,
	UNAVAILABLE_FOR_LEGAL_REASONS: 451,
	INTERNAL_SERVER_ERROR: 500,
	NOT_IMPLEMENTED: 501,
	BAD_GATEWAY: 502,
	SERVICE_UNAVAILABLE: 503,
	GATEWAY_TIMEOUT: 504,
	HTTP_VERSION_NOT_SUPPORTED: 505,
	VARIANT_ALSO_NEGOTIATES: 506,
	INSUFFICIENT_STORAGE: 507,
	LOOP_DETECTED: 508,
	NOT_EXTENDED: 510,
	NETWORK_AUTHENTICATION_REQUIRED: 511,
};

export type Status =
	| 100
	| 101
	| 102
	| 103
	| 200
	| 201
	| 202
	| 203
	| 204
	| 205
	| 206
	| 207
	| 208
	| 226
	| 300
	| 301
	| 302
	| 303
	| 304
	| 305
	| 306
	| 307
	| 308
	| 400
	| 401
	| 402
	| 403
	| 404
	| 405
	| 406
	| 407
	| 408
	| 409
	| 410
	| 411
	| 412
	| 413
	| 414
	| 415
	| 416
	| 417
	| 418
	| 421
	| 422
	| 423
	| 424
	| 425
	| 426
	| 428
	| 429
	| 431
	| 451
	| 500
	| 501
	| 502
	| 503
	| 504
	| 505
	| 506
	| 507
	| 508
	| 510
	| 511;

export class APIError extends Error {
	constructor(
		public status: keyof typeof _statusCode | Status = "INTERNAL_SERVER_ERROR",
		public body:
			| ({
					message?: string;
					code?: string;
			  } & Record<string, any>)
			| undefined = undefined,
		public headers: HeadersInit = {},
		public statusCode = typeof status === "number" ? status : _statusCode[status],
	) {
		super(body?.message);
		this.name = "APIError";
		this.status = status;
		this.headers = headers;
		this.statusCode = statusCode;
		this.body = body
			? {
					code: body?.message
						?.toUpperCase()
						.replace(/ /g, "_")
						.replace(/[^A-Z0-9_]/g, ""),
					...body,
				}
			: undefined;
		this.stack = "";
	}
}



================================================
File: src/helper.ts
================================================
/**
 * Improve this type if possible
 */
export type Input<T> = {
	[K in keyof T as T[K] extends never ? never : undefined extends T[K] ? never : K]: T[K];
} & {
	[K in keyof T as undefined extends T[K] ? K : never]?: T[K];
};

export type RequiredKeysOf<BaseType extends object> = Exclude<
	{
		[Key in keyof BaseType]: BaseType extends Record<Key, BaseType[Key]> ? Key : never;
	}[keyof BaseType],
	undefined
>;

export type HasRequiredKeys<BaseType extends object> = RequiredKeysOf<BaseType> extends never
	? false
	: true;

export type Prettify<T> = {
	[K in keyof T]: T[K];
} & {};

export type IsEmptyObject<T> = keyof T extends never ? true : false;

export type UnionToIntersection<Union> = (
	Union extends unknown
		? (distributedUnion: Union) => void
		: never
) extends (mergedIntersection: infer Intersection) => void
	? Intersection & Union
	: never;

export type MergeObject<
	T extends Record<string, any> | never,
	S extends Record<string, any> | never,
> = T extends never ? S : S extends never ? T : T & S;

export type InferParamPath<Path> = Path extends `${infer _Start}:${infer Param}/${infer Rest}`
	? { [K in Param | keyof InferParamPath<Rest>]: string }
	: Path extends `${infer _Start}:${infer Param}`
		? { [K in Param]: string }
		: Path extends `${infer _Start}/${infer Rest}`
			? InferParamPath<Rest>
			: {};

export type InferParamWildCard<Path> = Path extends
	| `${infer _Start}/*:${infer Param}/${infer Rest}`
	| `${infer _Start}/**:${infer Param}/${infer Rest}`
	? { [K in Param | keyof InferParamPath<Rest>]: string }
	: Path extends `${infer _Start}/*`
		? { [K in "_"]: string }
		: Path extends `${infer _Start}/${infer Rest}`
			? InferParamPath<Rest>
			: {};



================================================
File: src/index.ts
================================================
export * from "./endpoint";
export * from "./middleware";
export * from "./router";
export * from "./cookies";
export * from "./openapi";
export * from "./error";
export * from "./context";
export * from "./to-response";
export * from "./helper";
export * from "./standard-schema";



================================================
File: src/middleware.test.ts
================================================
import { describe, expect, expectTypeOf, it } from "vitest";
import { createMiddleware } from "./middleware";
import { createEndpoint } from "./endpoint";

describe("type", () => {
	it("should infer middleware returned type", async () => {
		const middleware = createMiddleware(async (c) => {
			return {
				test: 1,
			};
		});
		const middleware2 = createMiddleware(async (c) => {
			return {
				hello: "world",
			};
		});
		createEndpoint(
			"/",
			{
				method: "POST",
				use: [middleware, middleware2],
			},
			async (c) => {
				expectTypeOf(c.context).toMatchTypeOf<{
					hello: string;
					test: number;
				}>();
			},
		);
	});
});

describe("runtime", () => {
	it("should run middleware", async () => {
		const middleware = createMiddleware(async () => {
			return {
				hello: "world",
			};
		});
		const endpoint = createEndpoint(
			"/test",
			{
				method: "POST",
				use: [middleware],
			},
			async (ctx) => {
				return ctx.context;
			},
		);
		const response = await endpoint();
		expect(response).toMatchObject({
			hello: "world",
		});
	});

	it("should run multiple middleware", async () => {
		const middleware = createMiddleware(async () => {
			return {
				hello: "world",
			};
		});
		const middleware2 = createMiddleware(async () => {
			return {
				test: 2,
			};
		});
		const endpoint = createEndpoint(
			"/test",
			{
				method: "POST",
				use: [middleware, middleware2],
			},
			async (ctx) => {
				return ctx.context;
			},
		);
		const response = await endpoint();
		expect(response).toMatchObject({
			hello: "world",
			test: 2,
		});
	});
});

describe("creator", () => {
	it("should use creator middlewares", async () => {
		const creator = createMiddleware.create({
			use: [
				createMiddleware(async (c) => {
					return {
						hello: "world",
					};
				}),
			],
		});

		const middleware = creator(async (c) => {
			expectTypeOf(c.context).toMatchTypeOf<{
				hello: string;
			}>();

			return c.context;
		});

		const endpoint = createEndpoint(
			"/",
			{
				use: [middleware],
				method: "GET",
			},
			async (c) => {
				return c.context;
			},
		);
		const response = await endpoint();
		expect(response).toMatchObject({
			hello: "world",
		});
	});

	it("should be able to combine with local middleware", async () => {
		const creator = createMiddleware.create({
			use: [
				createMiddleware(async () => {
					return {
						hello: "world",
					};
				}),
			],
		});
		const middleware = creator(
			{
				use: [
					createMiddleware(async () => {
						return {
							test: "payload",
						};
					}),
				],
			},
			async (c) => {
				return c.context;
			},
		);

		const endpoint = createEndpoint(
			"/path",
			{
				use: [middleware],
				method: "POST",
			},
			async (c) => {
				return c.context;
			},
		);
		const response = await endpoint();
		expect(response).toMatchObject({
			hello: "world",
			test: "payload",
		});
	});
});



================================================
File: src/middleware.ts
================================================
import {
	createEndpoint,
	type Endpoint,
	type EndpointContext,
	type EndpointOptions,
} from "./endpoint";
import {
	createInternalContext,
	type InferBody,
	type InferHeaders,
	type InferMiddlewareBody,
	type InferMiddlewareQuery,
	type InferQuery,
	type InferRequest,
	type InferUse,
	type InputContext,
} from "./context";
import type { Input, Prettify } from "./helper";

export interface MiddlewareOptions extends Omit<EndpointOptions, "method"> {}

export type MiddlewareResponse = null | void | undefined | Record<string, any>;

export type MiddlewareContext<Options extends MiddlewareOptions, Context = {}> = EndpointContext<
	string,
	Options & {
		method: "*";
	}
> & {
	/**
	 * Method
	 *
	 * The request method
	 */
	method: string;
	/**
	 * Path
	 *
	 * The path of the endpoint
	 */
	path: string;
	/**
	 * Body
	 *
	 * The body object will be the parsed JSON from the request and validated
	 * against the body schema if it exists
	 */
	body: InferMiddlewareBody<Options>;
	/**
	 * Query
	 *
	 * The query object will be the parsed query string from the request
	 * and validated against the query schema if it exists
	 */
	query: InferMiddlewareQuery<Options>;
	/**
	 * Params
	 *
	 * If the path is `/user/:id` and the request is `/user/1` then the
	 * params will
	 * be `{ id: "1" }` and if the path includes a wildcard like `/user/*`
	 * then the
	 * params will be `{ _: "1" }` where `_` is the wildcard key. If the
	 * wildcard
	 * is named like `/user/**:name` then the params will be `{ name: string }`
	 */
	params: string;
	/**
	 * Request object
	 *
	 * If `requireRequest` is set to true in the endpoint options this will be
	 * required
	 */
	request: InferRequest<Options>;
	/**
	 * Headers
	 *
	 * If `requireHeaders` is set to true in the endpoint options this will be
	 * required
	 */
	headers: InferHeaders<Options>;
	/**
	 * Set header
	 *
	 * If it's called outside of a request it will just be ignored.
	 */
	setHeader: (key: string, value: string) => void;
	/**
	 * Get header
	 *
	 * If it's called outside of a request it will just return null
	 *
	 * @param key  - The key of the header
	 * @returns
	 */
	getHeader: (key: string) => string | null;
	/**
	 * JSON
	 *
	 * a helper function to create a JSON response with
	 * the correct headers
	 * and status code. If `asResponse` is set to true in
	 * the context then
	 * it will return a Response object instead of the
	 * JSON object.
	 *
	 * @param json - The JSON object to return
	 * @param routerResponse - The response object to
	 * return if `asResponse` is
	 * true in the context this will take precedence
	 */
	json: <R extends Record<string, any> | null>(
		json: R,
		routerResponse?:
			| {
					status?: number;
					headers?: Record<string, string>;
					response?: Response;
			  }
			| Response,
	) => Promise<R>;
	/**
	 * Middleware context
	 */
	context: Prettify<Context>;
};

export function createMiddleware<Options extends MiddlewareOptions, R>(
	options: Options,
	handler: (context: MiddlewareContext<Options>) => Promise<R>,
): <InputCtx extends MiddlewareInputContext<Options>>(inputContext: InputCtx) => Promise<R>;
export function createMiddleware<Options extends MiddlewareOptions, R>(
	handler: (context: MiddlewareContext<Options>) => Promise<R>,
): <InputCtx extends MiddlewareInputContext<Options>>(inputContext: InputCtx) => Promise<R>;
export function createMiddleware(optionsOrHandler: any, handler?: any) {
	const internalHandler = async (inputCtx: InputContext<any, any>) => {
		const context = inputCtx as InputContext<any, any>;
		const _handler = typeof optionsOrHandler === "function" ? optionsOrHandler : handler;
		const options = typeof optionsOrHandler === "function" ? {} : optionsOrHandler;
		const internalContext = await createInternalContext(context, {
			options,
			path: "/",
		});

		if (!_handler) {
			throw new Error("handler must be defined");
		}
		const response = await _handler(internalContext as any);
		const headers = internalContext.responseHeaders;
		return context.returnHeaders
			? {
					headers,
					response,
				}
			: response;
	};
	internalHandler.options = typeof optionsOrHandler === "function" ? {} : optionsOrHandler;
	return internalHandler;
}

export type MiddlewareInputContext<Options extends MiddlewareOptions> = Input<{
	/**
	 * Payload
	 */
	body: InferBody<Options>;
	/**
	 * Query Params
	 */
	query: InferQuery<Options>;
	/**
	 * Request Object
	 */
	request: InferRequest<Options>;
	/**
	 * Headers
	 */
	headers: InferHeaders<Options>;
	/**
	 * Return a `Response` object
	 */
	asResponse?: boolean;
	/**
	 * include headers on the return
	 */
	returnHeaders?: boolean;
	/**
	 * Middlewares to use
	 */
	use?: Middleware[];
}>;

export type Middleware<
	Options extends MiddlewareOptions = MiddlewareOptions,
	Handler extends (inputCtx: any) => Promise<any> = any,
> = Handler & {
	options: Options;
};

createMiddleware.create = <
	E extends {
		use?: Middleware[];
	},
>(
	opts?: E,
) => {
	type InferredContext = InferUse<E["use"]>;
	function fn<Options extends MiddlewareOptions, R>(
		options: Options,
		handler: (ctx: MiddlewareContext<Options, InferredContext>) => Promise<R>,
	): (inputContext: MiddlewareInputContext<Options>) => Promise<R>;
	function fn<Options extends MiddlewareOptions, R>(
		handler: (ctx: MiddlewareContext<Options, InferredContext>) => Promise<R>,
	): (inputContext: MiddlewareInputContext<Options>) => Promise<R>;
	function fn(optionsOrHandler: any, handler?: any) {
		if (typeof optionsOrHandler === "function") {
			return createMiddleware(
				{
					use: opts?.use,
				},
				optionsOrHandler,
			);
		}
		if (!handler) {
			throw new Error("Middleware handler is required");
		}
		const middleware = createMiddleware(
			{
				...optionsOrHandler,
				method: "*",
				use: [...(opts?.use || []), ...(optionsOrHandler.use || [])],
			},
			handler,
		);
		return middleware as any;
	}
	return fn;
};



================================================
File: src/openapi.ts
================================================
import { ZodObject, ZodOptional, ZodSchema } from "zod";
import type { Endpoint, EndpointOptions } from "./endpoint";

export type OpenAPISchemaType = "string" | "number" | "integer" | "boolean" | "array" | "object";

export interface OpenAPIParameter {
	in: "query" | "path" | "header" | "cookie";
	name?: string;
	description?: string;
	required?: boolean;
	schema?: {
		type: OpenAPISchemaType;
		format?: string;
		items?: {
			type: OpenAPISchemaType;
		};
		enum?: string[];
		minLength?: number;
		description?: string;
		default?: string;
		example?: string;
	};
}

export interface Path {
	get?: {
		tags?: string[];
		operationId?: string;
		description?: string;
		security?: [{ bearerAuth: string[] }];
		parameters?: OpenAPIParameter[];
		responses?: {
			[key in string]: {
				description?: string;
				content: {
					"application/json": {
						schema: {
							type?: OpenAPISchemaType;
							properties?: Record<string, any>;
							required?: string[];
							$ref?: string;
						};
					};
				};
			};
		};
	};
	post?: {
		tags?: string[];
		operationId?: string;
		description?: string;
		security?: [{ bearerAuth: string[] }];
		parameters?: OpenAPIParameter[];
		requestBody?: {
			content: {
				"application/json": {
					schema: {
						type?: OpenAPISchemaType;
						properties?: Record<string, any>;
						required?: string[];
						$ref?: string;
					};
				};
			};
		};
		responses?: {
			[key in string]: {
				description?: string;
				content: {
					"application/json": {
						schema: {
							type?: OpenAPISchemaType;
							properties?: Record<string, any>;
							required?: string[];
							$ref?: string;
						};
					};
				};
			};
		};
	};
}
const paths: Record<string, Path> = {};

function getTypeFromZodType(zodType: ZodSchema) {
	switch (zodType.constructor.name) {
		case "ZodString":
			return "string";
		case "ZodNumber":
			return "number";
		case "ZodBoolean":
			return "boolean";
		case "ZodObject":
			return "object";
		case "ZodArray":
			return "array";
		default:
			return "string";
	}
}

function getParameters(options: EndpointOptions) {
	const parameters: OpenAPIParameter[] = [];
	if (options.metadata?.openapi?.parameters) {
		parameters.push(...options.metadata.openapi.parameters);
		return parameters;
	}
	if (options.query instanceof ZodObject) {
		Object.entries(options.query.shape).forEach(([key, value]) => {
			if (value instanceof ZodSchema) {
				parameters.push({
					name: key,
					in: "query",
					schema: {
						type: getTypeFromZodType(value),
						...("minLength" in value && value.minLength
							? {
									minLength: value.minLength as number,
								}
							: {}),
						description: value.description,
					},
				});
			}
		});
	}
	return parameters;
}

function getRequestBody(options: EndpointOptions): any {
	if (options.metadata?.openapi?.requestBody) {
		return options.metadata.openapi.requestBody;
	}
	if (!options.body) return undefined;
	if (options.body instanceof ZodObject || options.body instanceof ZodOptional) {
		// @ts-ignore
		const shape = options.body.shape;
		if (!shape) return undefined;
		const properties: Record<string, any> = {};
		const required: string[] = [];
		Object.entries(shape).forEach(([key, value]) => {
			if (value instanceof ZodSchema) {
				properties[key] = {
					type: getTypeFromZodType(value),
					description: value.description,
				};
				if (!(value instanceof ZodOptional)) {
					required.push(key);
				}
			}
		});
		return {
			required: options.body instanceof ZodOptional ? false : options.body ? true : false,
			content: {
				"application/json": {
					schema: {
						type: "object",
						properties,
						required,
					},
				},
			},
		};
	}
	return undefined;
}

function getResponse(responses?: Record<string, any>) {
	return {
		"400": {
			content: {
				"application/json": {
					schema: {
						type: "object",
						properties: {
							message: {
								type: "string",
							},
						},
						required: ["message"],
					},
				},
			},
			description: "Bad Request. Usually due to missing parameters, or invalid parameters.",
		},
		"401": {
			content: {
				"application/json": {
					schema: {
						type: "object",
						properties: {
							message: {
								type: "string",
							},
						},
						required: ["message"],
					},
				},
			},
			description: "Unauthorized. Due to missing or invalid authentication.",
		},
		"403": {
			content: {
				"application/json": {
					schema: {
						type: "object",
						properties: {
							message: {
								type: "string",
							},
						},
					},
				},
			},
			description:
				"Forbidden. You do not have permission to access this resource or to perform this action.",
		},
		"404": {
			content: {
				"application/json": {
					schema: {
						type: "object",
						properties: {
							message: {
								type: "string",
							},
						},
					},
				},
			},
			description: "Not Found. The requested resource was not found.",
		},
		"429": {
			content: {
				"application/json": {
					schema: {
						type: "object",
						properties: {
							message: {
								type: "string",
							},
						},
					},
				},
			},
			description: "Too Many Requests. You have exceeded the rate limit. Try again later.",
		},
		"500": {
			content: {
				"application/json": {
					schema: {
						type: "object",
						properties: {
							message: {
								type: "string",
							},
						},
					},
				},
			},
			description:
				"Internal Server Error. This is a problem with the server that you cannot fix.",
		},
		...responses,
	} as any;
}

export async function generator(
	endpoints: Record<string, Endpoint>,
	config?: {
		url: string;
	},
) {
	const components = {
		schemas: {},
	};

	Object.entries(endpoints).forEach(([_, value]) => {
		const options = value.options as EndpointOptions;
		if (options.metadata?.SERVER_ONLY) return;
		if (options.method === "GET") {
			paths[value.path] = {
				get: {
					tags: ["Default", ...(options.metadata?.openapi?.tags || [])],
					description: options.metadata?.openapi?.description,
					operationId: options.metadata?.openapi?.operationId,
					security: [
						{
							bearerAuth: [],
						},
					],
					parameters: getParameters(options),
					responses: getResponse(options.metadata?.openapi?.responses),
				},
			};
		}

		if (options.method === "POST") {
			const body = getRequestBody(options);
			paths[value.path] = {
				post: {
					tags: ["Default", ...(options.metadata?.openapi?.tags || [])],
					description: options.metadata?.openapi?.description,
					operationId: options.metadata?.openapi?.operationId,
					security: [
						{
							bearerAuth: [],
						},
					],
					parameters: getParameters(options),
					...(body
						? { requestBody: body }
						: {
								requestBody: {
									//set body none
									content: {
										"application/json": {
											schema: {
												type: "object",
												properties: {},
											},
										},
									},
								},
							}),
					responses: getResponse(options.metadata?.openapi?.responses),
				},
			};
		}
	});

	const res = {
		openapi: "3.1.1",
		info: {
			title: "Better Auth",
			description: "API Reference for your Better Auth Instance",
			version: "1.1.0",
		},
		components,
		security: [
			{
				apiKeyCookie: [],
			},
		],
		servers: [
			{
				url: config?.url,
			},
		],
		tags: [
			{
				name: "Default",
				description:
					"Default endpoints that are included with Better Auth by default. These endpoints are not part of any plugin.",
			},
		],
		paths,
	};
	return res;
}

export const getHTML = (
	apiReference: Record<string, any>,
	config?: {
		logo?: string;
		theme?: string;
		title?: string;
		description?: string;
	},
) => `<!doctype html>
<html>
  <head>
    <title>Scalar API Reference</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1" />
  </head>
  <body>
    <script
      id="api-reference"
      type="application/json">
    ${JSON.stringify(apiReference)}
    </script>
	 <script>
      var configuration = {
	  	favicon: ${config?.logo ? `data:image/svg+xml;utf8,${encodeURIComponent(config.logo)}` : undefined} ,
	   	theme: ${config?.theme || "saturn"},
        metaData: {
			title: ${config?.title || "Open API Reference"},
			description: ${config?.description || "Better Call Open API"},
		}
      }
      document.getElementById('api-reference').dataset.configuration =
        JSON.stringify(configuration)
    </script>
	  <script src="https://cdn.jsdelivr.net/npm/@scalar/api-reference"></script>
  </body>
</html>`;



================================================
File: src/router.test.ts
================================================
import { describe, expect, it } from "vitest";
import { createEndpoint, type Endpoint } from "./endpoint";
import { createRouter } from "./router";
import { z } from "zod";
import { APIError } from "./error";

describe("router", () => {
	it("should be able to return simple response", async () => {
		const endpoint = createEndpoint(
			"/",
			{
				method: "GET",
			},
			async () => {
				return "hello world";
			},
		);
		const router = createRouter({
			endpoint,
		});
		const request = new Request("http://localhost:3000");
		const response = await router.handler(request);
		const text = await response.text();
		expect(text).toBe("hello world");
	});
	it("should be able to router properly", async () => {
		const routes: {
			path: string;
			method: string;
			body?: any;
		}[] = [
			{
				path: "/",
				method: "GET",
			},
			{
				path: "/post",
				method: "POST",
			},
			{
				path: "/patch",
				method: "PATCH",
			},
			{
				path: "/delete",
				method: "DELETE",
			},
			{
				path: "/put",
				method: "PUT",
			},
		];
		const endpoints: Record<string, Endpoint> = {};
		for (const route of routes) {
			const endpoint = createEndpoint(
				route.path,
				{
					method: route.method as "GET",
				},
				async () => {
					return route.path;
				},
			);
			endpoints[route.path] = endpoint;
		}

		const router = createRouter(endpoints);
		for (const route of routes) {
			const request = new Request(`http://localhost:3000${route.path}`, {
				method: route.method,
			});
			const response = await router.handler(request).then((res) => res.text());
			expect(response).toBe(route.path);
		}
	});

	it("requests with a body", async () => {
		const endpoint = createEndpoint(
			"/post",
			{
				method: "POST",
				body: z.object({
					name: z.string(),
				}),
			},
			async (c) => {
				return c.body;
			},
		);
		const router = createRouter({
			endpoint,
		});
		const request = new Request("http://localhost/post", {
			body: JSON.stringify({
				name: "hello",
			}),
			method: "POST",
			headers: {
				"Content-Type": "application/json",
			},
		});
		const response = await router.handler(request).then((res) => res.json());
		expect(response).toMatchObject({ name: "hello" });
	});

	it("should work with request with a query param", async () => {
		const endpoint = createEndpoint(
			"/post",
			{
				method: "POST",
				query: z.object({
					name: z.string(),
				}),
			},
			async (c) => {
				return c.query;
			},
		);
		const router = createRouter({
			endpoint,
		});
		const request = new Request("http://localhost/post?name=hello", {
			method: "POST",
		});
		const response = await router.handler(request).then((res) => res.json());
		expect(response).toMatchObject({ name: "hello" });
	});

	it("should work with request with dynamic param", async () => {
		const endpoint = createEndpoint(
			"/post/:id",
			{
				method: "POST",
			},
			async (c) => {
				return c.params;
			},
		);
		const router = createRouter({
			endpoint,
		});
		const request = new Request("http://localhost/post/1", {
			method: "POST",
		});
		const response = await router.handler(request).then((res) => res.json());
		expect(response).toMatchObject({ id: "1" });
	});

	it("should handle API Errors", async () => {
		const endpoint = createEndpoint(
			"/",
			{
				method: "GET",
			},
			async () => {
				throw new APIError("FORBIDDEN");
			},
		);
		const router = createRouter({ endpoint });
		const response = await router.handler(new Request("http://localhost"));
		expect(response.status).toBe(403);
	});
});

describe("route middleware", () => {
	it("should apply middleware as context", async () => {
		const endpoint = createEndpoint(
			"/",
			{
				method: "GET",
			},
			async (c) => {
				const cx = c.json({ name: "hello" });
				return cx;
			},
		);
		const router = createRouter({ endpoint });
		const response = await router.handler(new Request("http://localhost"));
		const json = await response.json();
		expect(json).toMatchObject({ name: "hello" });
	});
});



================================================
File: src/router.ts
================================================
import { createRouter as createRou3Router, addRoute, findRoute, findAllRoutes } from "rou3";
import { createEndpoint, type Endpoint } from "./endpoint";
import { generator, getHTML } from "./openapi";
import type { Middleware } from "./middleware";
import { getBody, isAPIError } from "./utils";
import { APIError } from "./error";
import { toResponse } from "./to-response";

export interface RouterConfig {
	throwError?: boolean;
	onError?: (e: unknown) => void | Promise<void> | Response | Promise<Response>;
	basePath?: string;
	routerMiddleware?: Array<{
		path: string;
		middleware: Middleware;
	}>;
	/**
	 * additional Context that needs to passed to endpoints
	 *
	 * this will be available on `ctx.context` on endpoints
	 */
	routerContext?: Record<string, any>;
	/**
	 * A callback to run before any response
	 */
	onResponse?: (res: Response) => any | Promise<any>;
	/**
	 * A callback to run before any request
	 */
	onRequest?: (req: Request) => any | Promise<any>;
	/**
	 * Open API route configuration
	 */
	openapi?: {
		/**
		 * Disable openapi route
		 *
		 * @default false
		 */
		disabled?: boolean;
		/**
		 * A path to display open api using scalar
		 *
		 * @default "/api/reference"
		 */
		path?: string;
		/**
		 * Scalar Configuration
		 */
		scalar?: {
			/**
			 * Title
			 * @default "Open API Reference"
			 */
			title?: string;
			/**
			 * Description
			 *
			 * @default "Better Call Open API Reference"
			 */
			description?: string;
			/**
			 * Logo URL
			 */
			logo?: string;
			/**
			 * Scalar theme
			 * @default "saturn"
			 */
			theme?: string;
		};
	};
}

export const createRouter = <E extends Record<string, Endpoint>, Config extends RouterConfig>(
	endpoints: E,
	config?: Config,
) => {
	if (!config?.openapi?.disabled) {
		const openapi = {
			path: "/api/reference",
			...config?.openapi,
		};
		//@ts-expect-error
		endpoints["openapi"] = createEndpoint(
			openapi.path,
			{
				method: "GET",
			},
			async (c) => {
				const schema = await generator(endpoints);
				return new Response(getHTML(schema, openapi.scalar), {
					headers: {
						"Content-Type": "text/html",
					},
				});
			},
		);
	}
	const router = createRou3Router();
	const middlewareRouter = createRou3Router();

	for (const endpoint of Object.values(endpoints)) {
		if (!endpoint.options) {
			continue;
		}
		if (endpoint.options?.metadata?.SERVER_ONLY) continue;

		const methods = Array.isArray(endpoint.options?.method)
			? endpoint.options.method
			: [endpoint.options?.method];

		for (const method of methods) {
			addRoute(router, method, endpoint.path, endpoint);
		}
	}

	if (config?.routerMiddleware?.length) {
		for (const { path, middleware } of config.routerMiddleware) {
			addRoute(middlewareRouter, "*", path, middleware);
		}
	}

	const processRequest = async (request: Request) => {
		const url = new URL(request.url);
		const path = config?.basePath ? url.pathname.split(config.basePath)[1] : url.pathname;

		if (!path?.length) {
			config?.onError?.(new Error("NOT_FOUND"));
			return new Response(null, { status: 404, statusText: "Not Found" });
		}

		const route = findRoute(router, request.method, path);
		if (!route?.data) {
			return new Response(null, { status: 404, statusText: "Not Found" });
		}

		const handler = route.data as Endpoint;
		const context = {
			path,
			method: request.method as "GET",
			headers: request.headers,
			params: route.params ? (JSON.parse(JSON.stringify(route.params)) as any) : {},
			request: request,
			body: await getBody(handler.options.cloneRequest ? request.clone() : request),
			query: Object.fromEntries(url.searchParams),
			_flag: "router" as const,
			asResponse: true,
			context: config?.routerContext,
		};

		try {
			const middlewareRoutes = findAllRoutes(middlewareRouter, "*", path);
			if (middlewareRoutes?.length) {
				for (const { data: middleware, params } of middlewareRoutes) {
					const res = await (middleware as Endpoint)({
						...context,
						params,
						asResponse: false,
					});

					if (res instanceof Response) return res;
				}
			}

			const response = (await handler(context)) as Response;
			return response;
		} catch (error) {
			if (isAPIError(error)) {
				return toResponse(error);
			}
			console.error(`# SERVER_ERROR: `, error);
			return new Response(null, {
				status: 500,
				statusText: "Internal Server Error",
			});
		}
	};

	return {
		handler: async (request: Request) => {
			const onReq = await config?.onRequest?.(request);
			if (onReq instanceof Response) {
				return onReq;
			}
			const req = onReq instanceof Request ? onReq : request;
			const res = await processRequest(req);
			const onRes = await config?.onResponse?.(res);
			if (onRes instanceof Response) {
				return onRes;
			}
			return res;
		},
		endpoints,
	};
};

export type Router = ReturnType<typeof createRouter>;



================================================
File: src/standard-schema.ts
================================================
/** The Standard Schema interface. */
export interface StandardSchemaV1<Input = unknown, Output = Input> {
	/** The Standard Schema properties. */
	readonly "~standard": StandardSchemaV1.Props<Input, Output>;
}

export declare namespace StandardSchemaV1 {
	/** The Standard Schema properties interface. */
	export interface Props<Input = unknown, Output = Input> {
		/** The version number of the standard. */
		readonly version: 1;
		/** The vendor name of the schema library. */
		readonly vendor: string;
		/** Validates unknown input values. */
		readonly validate: (value: unknown) => Result<Output> | Promise<Result<Output>>;
		/** Inferred types associated with the schema. */
		readonly types?: Types<Input, Output> | undefined;
	}

	/** The result interface of the validate function. */
	export type Result<Output> = SuccessResult<Output> | FailureResult;

	/** The result interface if validation succeeds. */
	export interface SuccessResult<Output> {
		/** The typed output value. */
		readonly value: Output;
		/** The non-existent issues. */
		readonly issues?: undefined;
	}

	/** The result interface if validation fails. */
	export interface FailureResult {
		/** The issues of failed validation. */
		readonly issues: ReadonlyArray<Issue>;
	}

	/** The issue interface of the failure output. */
	export interface Issue {
		/** The error message of the issue. */
		readonly message: string;
		/** The path of the issue, if any. */
		readonly path?: ReadonlyArray<PropertyKey | PathSegment> | undefined;
	}

	/** The path segment interface of the issue. */
	export interface PathSegment {
		/** The key representing a path segment. */
		readonly key: PropertyKey;
	}

	/** The Standard Schema types interface. */
	export interface Types<Input = unknown, Output = Input> {
		/** The input type of the schema. */
		readonly input: Input;
		/** The output type of the schema. */
		readonly output: Output;
	}

	/** Infers the input type of a Standard Schema. */
	export type InferInput<Schema extends StandardSchemaV1> = NonNullable<
		Schema["~standard"]["types"]
	>["input"];

	/** Infers the output type of a Standard Schema. */
	export type InferOutput<Schema extends StandardSchemaV1> = NonNullable<
		Schema["~standard"]["types"]
	>["output"];
}



================================================
File: src/to-response.ts
================================================
import { APIError } from "./error";
import { isAPIError } from "./utils";

function isJSONSerializable(value: any) {
	if (value === undefined) {
		return false;
	}
	const t = typeof value;
	if (t === "string" || t === "number" || t === "boolean" || t === null) {
		return true;
	}
	if (t !== "object") {
		return false;
	}
	if (Array.isArray(value)) {
		return true;
	}
	if (value.buffer) {
		return false;
	}
	return (
		(value.constructor && value.constructor.name === "Object") ||
		typeof value.toJSON === "function"
	);
}

export function toResponse(data?: any, init?: ResponseInit): Response {
	if (data instanceof Response) {
		if (init?.headers instanceof Headers) {
			init.headers.forEach((value, key) => {
				data.headers.set(key, value);
			});
		}
		return data;
	}
	if (data?._flag === "json") {
		const routerResponse = data.routerResponse;
		if (routerResponse instanceof Response) {
			return routerResponse;
		}
		return toResponse(data.body, {
			headers: data.headers,
			status: data.status,
		});
	}
	if (isAPIError(data)) {
		return toResponse(data.body, {
			status: data.statusCode,
			statusText: data.status.toString(),
			headers: init?.headers || data.headers,
		});
	}
	let body = data;
	let headers = new Headers(init?.headers);
	if (!data) {
		headers.set("content-type", "application/json");
	} else if (typeof data === "string") {
		body = data;
		headers.set("Content-Type", "text/plain");
	} else if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
		body = data;
		headers.set("Content-Type", "application/octet-stream");
	} else if (data instanceof Blob) {
		body = data;
		headers.set("Content-Type", data.type || "application/octet-stream");
	} else if (data instanceof FormData) {
		body = data;
	} else if (data instanceof URLSearchParams) {
		body = data;
		headers.set("Content-Type", "application/x-www-form-urlencoded");
	} else if (data instanceof ReadableStream) {
		body = data;
		headers.set("Content-Type", "application/octet-stream");
	} else if (isJSONSerializable(data)) {
		body = JSON.stringify(data);
		headers.set("Content-Type", "application/json");
	}

	return new Response(body, {
		...init,
		headers,
	});
}



================================================
File: src/utils.ts
================================================
import { APIError } from "./error";

export async function getBody(request: Request) {
	const contentType = request.headers.get("content-type") || "";

	if (!request.body) {
		return undefined;
	}

	if (contentType.includes("application/json")) {
		return await request.json();
	}

	if (contentType.includes("application/x-www-form-urlencoded")) {
		const formData = await request.formData();
		const result: Record<string, string> = {};
		formData.forEach((value, key) => {
			result[key] = value.toString();
		});
		return result;
	}

	if (contentType.includes("multipart/form-data")) {
		const formData = await request.formData();
		const result: Record<string, any> = {};
		formData.forEach((value, key) => {
			result[key] = value;
		});
		return result;
	}

	if (contentType.includes("text/plain")) {
		return await request.text();
	}

	if (contentType.includes("application/octet-stream")) {
		return await request.arrayBuffer();
	}

	if (
		contentType.includes("application/pdf") ||
		contentType.includes("image/") ||
		contentType.includes("video/")
	) {
		const blob = await request.blob();
		return blob;
	}

	if (contentType.includes("application/stream") || request.body instanceof ReadableStream) {
		return request.body;
	}

	return await request.text();
}

export function isAPIError(error: any) {
	return error instanceof APIError || error?.name === "APIError";
}

export function tryDecode(str: string) {
	try {
		return str.includes("%") ? decodeURIComponent(str) : str;
	} catch {
		return str;
	}
}



================================================
File: src/validator.ts
================================================
import type { EndpointOptions } from "./endpoint";
import type { InputContext } from "./context";
import type { StandardSchemaV1 } from "./standard-schema";

type ValidationResponse =
	| {
			data: {
				body: any;
				query: any;
			};
			error: null;
	  }
	| {
			data: null;
			error: {
				message: string;
			};
	  };

/**
 * Runs validation on body and query
 * @returns error and data object
 */
export async function runValidation(
	options: EndpointOptions,
	context: InputContext<any, any> = {},
): Promise<ValidationResponse> {
	let request = {
		body: context.body,
		query: context.query,
	} as {
		body: any;
		query: any;
	};
	if (options.body) {
		const result = await options.body["~standard"].validate(context.body);
		if (result.issues) {
			return {
				data: null,
				error: fromError(result.issues, "body"),
			};
		}
		request.body = result.value;
	}

	if (options.query) {
		const result = await options.query["~standard"].validate(context.query);
		if (result.issues) {
			return {
				data: null,
				error: fromError(result.issues, "query"),
			};
		}
		request.query = result.value;
	}
	if (options.requireHeaders && !context.headers) {
		return {
			data: null,
			error: { message: "Headers is required" },
		};
	}
	if (options.requireRequest && !context.request) {
		return {
			data: null,
			error: { message: "Request is required" },
		};
	}
	return {
		data: request,
		error: null,
	};
}

export function fromError(error: readonly StandardSchemaV1.Issue[], validating: string) {
	const errorMessages: string[] = [];

	for (const issue of error) {
		const message = issue.message;
		errorMessages.push(message);
	}
	return {
		message: `Invalid ${validating} parameters`,
	};
}



================================================
File: src/adapters/node/index.ts
================================================
import type { IncomingMessage, ServerResponse } from "node:http";

import { getRequest, setResponse } from "./request";
import type { Router } from "../../router.js";

export function toNodeHandler(handler: Router["handler"]) {
	return async (req: IncomingMessage, res: ServerResponse) => {
		const protocol =
			req.headers["x-forwarded-proto"] || ((req.socket as any).encrypted ? "https" : "http");
		const base = `${protocol}://${req.headers[":authority"] || req.headers.host}`;
		const response = await handler(getRequest({ base, request: req }));
		return setResponse(res, response);
	};
}

export { getRequest, setResponse };



================================================
File: src/adapters/node/node.ts
================================================
import type { IncomingMessage, ServerResponse } from "node:http";

import { getRequest, setResponse } from "./request";
import type { Router } from "../../router.js";

export function toNodeHandler(handler: Router["handler"]) {
	return async (req: IncomingMessage, res: ServerResponse) => {
		const protocol =
			req.headers["x-forwarded-proto"] || ((req.socket as any).encrypted ? "https" : "http");
		const base = `${protocol}://${req.headers[":authority"] || req.headers.host}`;
		const response = await handler(getRequest({ base, request: req }));
		return setResponse(res, response);
	};
}

export { getRequest, setResponse };



================================================
File: src/adapters/node/request.ts
================================================
import type { IncomingMessage, ServerResponse } from "node:http";
import * as set_cookie_parser from "set-cookie-parser";

function get_raw_body(req: IncomingMessage, body_size_limit?: number) {
	const h = req.headers;

	if (!h["content-type"]) return null;

	const content_length = Number(h["content-length"]);

	// check if no request body
	if (
		(req.httpVersionMajor === 1 && isNaN(content_length) && h["transfer-encoding"] == null) ||
		content_length === 0
	) {
		return null;
	}

	let length = content_length;

	if (body_size_limit) {
		if (!length) {
			length = body_size_limit;
		} else if (length > body_size_limit) {
			throw Error(
				`Received content-length of ${length}, but only accept up to ${body_size_limit} bytes.`,
			);
		}
	}

	if (req.destroyed) {
		const readable = new ReadableStream();
		readable.cancel();
		return readable;
	}

	let size = 0;
	let cancelled = false;

	return new ReadableStream({
		start(controller) {
			req.on("error", (error) => {
				cancelled = true;
				controller.error(error);
			});

			req.on("end", () => {
				if (cancelled) return;
				controller.close();
			});

			req.on("data", (chunk) => {
				if (cancelled) return;

				size += chunk.length;

				if (size > length) {
					cancelled = true;

					controller.error(
						new Error(
							`request body size exceeded ${
								content_length ? "'content-length'" : "BODY_SIZE_LIMIT"
							} of ${length}`,
						),
					);
					return;
				}

				controller.enqueue(chunk);

				if (controller.desiredSize === null || controller.desiredSize <= 0) {
					req.pause();
				}
			});
		},

		pull() {
			req.resume();
		},

		cancel(reason) {
			cancelled = true;
			req.destroy(reason);
		},
	});
}

export function getRequest({
	request,
	base,
	bodySizeLimit,
}: {
	base: string;
	bodySizeLimit?: number;
	request: IncomingMessage;
}) {
	return new Request(base + request.url, {
		// @ts-expect-error
		duplex: "half",
		method: request.method,
		body: get_raw_body(request, bodySizeLimit),
		headers: request.headers as Record<string, string>,
	});
}

export async function setResponse(res: ServerResponse, response: Response) {
	for (const [key, value] of response.headers as any) {
		try {
			res.setHeader(
				key,
				key === "set-cookie"
					? set_cookie_parser.splitCookiesString(response.headers.get(key) as string)
					: value,
			);
		} catch (error) {
			res.getHeaderNames().forEach((name) => res.removeHeader(name));
			res.writeHead(500).end(String(error));
			return;
		}
	}

	res.writeHead(response.status);

	if (!response.body) {
		res.end();
		return;
	}

	if (response.body.locked) {
		res.end(
			"Fatal error: Response body is locked. " +
				"This can happen when the response was already read (for example through 'response.json()' or 'response.text()').",
		);
		return;
	}

	const reader = response.body.getReader();

	if (res.destroyed) {
		reader.cancel();
		return;
	}

	const cancel = (error?: Error) => {
		res.off("close", cancel);
		res.off("error", cancel);

		// If the reader has already been interrupted with an error earlier,
		// then it will appear here, it is useless, but it needs to be catch.
		reader.cancel(error).catch(() => {});
		if (error) res.destroy(error);
	};

	res.on("close", cancel);
	res.on("error", cancel);

	next();
	async function next() {
		try {
			for (;;) {
				const { done, value } = await reader.read();

				if (done) break;

				if (!res.write(value)) {
					res.once("drain", next);
					return;
				}
			}
			res.end();
		} catch (error) {
			cancel(error instanceof Error ? error : new Error(String(error)));
		}
	}
}



================================================
File: .github/workflows/ci.yml
================================================
name: CI

on: 
    pull_request:  
        branches: main
    push: 
        branches: main
    merge_group: {}

jobs:
    test:
        runs-on: ubuntu-latest
        steps:
            - uses: actions/checkout@v4
              with:
                    fetch-depth: 0

            - uses: pnpm/action-setup@v4

            - uses: actions/setup-node@v4
              with:
                node-version: 20.x
                registry-url: 'https://registry.npmjs.org'
                cache: pnpm
            
            - name: Install
              run: pnpm install

            - name: Build
              run: pnpm build
            
            - name: Lint
              run: pnpm lint
            
            - name: Test
              run: pnpm test

            - name: Typecheck
              run: pnpm typecheck
            


================================================
File: .github/workflows/release.yml
================================================
name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: 20.x

      - run: npx changelogithub
        env:
          GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}
          
      - uses: pnpm/action-setup@v4

      - uses: actions/setup-node@v4
        with:
            node-version: 20.x
            registry-url: 'https://registry.npmjs.org'

      - run: pnpm install
      
      - name: Build
        run: pnpm build

      - name: Determine npm tag
        id: determine_npm_tag
        shell: bash
        run: |
          TAG="${GITHUB_REF#refs/tags/}"
          if [[ "$TAG" =~ -(next|canary|beta|rc) ]]; then
            # Extract pre-release tag (e.g., beta, rc)
            NPM_TAG=${BASH_REMATCH[1]}
          else
            # Check if the commit is on the main branch
            git fetch origin main
            if git merge-base --is-ancestor "$GITHUB_SHA" origin/main; then
              NPM_TAG="latest"
            else
              echo "The tagged commit is not on the main branch."
              echo "::error ::Releases with the 'latest' npm tag must be on the main branch."
              exit 1
            fi
          fi
          echo "npm_tag=$NPM_TAG" >> $GITHUB_OUTPUT
          echo "Using npm tag: $NPM_TAG"

      - name: Publish to npm
        run: pnpm -r publish --access public --no-git-checks --tag ${{ steps.determine_npm_tag.outputs.npm_tag }}
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

