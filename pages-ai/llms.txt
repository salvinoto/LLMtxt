Directory Structure:

└── ./
    ├── .changeset
    │   └── README.md
    ├── packages
    │   ├── core
    │   │   ├── src
    │   │   │   ├── commands.ts
    │   │   │   ├── engine.ts
    │   │   │   ├── index.test.ts
    │   │   │   ├── index.ts
    │   │   │   └── selector.ts
    │   │   ├── CHANGELOG.md
    │   │   └── README.md
    │   ├── dom
    │   │   ├── src
    │   │   │   ├── types
    │   │   │   │   └── domjson.d.ts
    │   │   │   ├── index.test.ts
    │   │   │   ├── index.ts
    │   │   │   ├── observer.ts
    │   │   │   └── serializer.ts
    │   │   ├── CHANGELOG.md
    │   │   └── README.md
    │   └── react
    │       ├── src
    │       │   ├── components
    │       │   │   ├── AIDevTools.tsx
    │       │   │   └── ClientWrapper.tsx
    │       │   ├── context.tsx
    │       │   ├── hooks.ts
    │       │   ├── index.test.tsx
    │       │   └── index.ts
    │       ├── CHANGELOG.md
    │       └── README.md
    ├── eslint.config.js
    ├── jest.config.js
    └── README.md



---
File: /.changeset/README.md
---

# Changesets

Hello and welcome! This folder has been automatically generated by `@changesets/cli`, a build tool that works
with multi-package repos, or single-package repos to help you version and publish your code. You can
find the full documentation for it [in our repository](https://github.com/changesets/changesets)

We have a quick list of common questions to get you started engaging with this project in
[our documentation](https://github.com/changesets/changesets/blob/main/docs/common-questions.md)



---
File: /packages/core/src/commands.ts
---

import { z } from 'zod';

// Base schema for all AI commands
export const BaseAICommandSchema = z.object({
  id: z.string().uuid().optional().describe('Unique identifier for the command instance'),
  type: z.string().describe('The type of the command'),
  selector: z.string().optional().describe('CSS-like selector targeting the element'),
  // Add other common fields if needed, e.g., metadata, targetFrameId
});

export type BaseAICommand = z.infer<typeof BaseAICommandSchema>;

// --- Specific Command Schemas (Non-Recursive First) ---

// Click Command
export const ClickCommandSchema = BaseAICommandSchema.extend({
  type: z.literal('click'),
  selector: z.string().describe('Selector for the element to click'),
  // Add click-specific options if needed (e.g., button, modifiers)
});
export type ClickCommand = z.infer<typeof ClickCommandSchema>;

// Fill Command
export const FillCommandSchema = BaseAICommandSchema.extend({
  type: z.literal('fill'),
  selector: z.string().describe('Selector for the input element to fill'),
  value: z.string().describe('The value to fill into the input'),
  // Add fill-specific options if needed (e.g., delay, force)
});
export type FillCommand = z.infer<typeof FillCommandSchema>;

// Set Attribute Command
export const SetAttrCommandSchema = BaseAICommandSchema.extend({
  type: z.literal('setAttr'),
  selector: z.string().describe('Selector for the element'),
  attribute: z.string().describe('The name of the attribute to set'),
  value: z.string().describe('The value to set for the attribute'),
});
export type SetAttrCommand = z.infer<typeof SetAttrCommandSchema>;

// Undo Command (Placeholder - actual logic in engine)
export const UndoCommandSchema = BaseAICommandSchema.extend({
  type: z.literal('undo'),
  // Undo might target a specific command ID or just the last action
  targetCommandId: z.string().uuid().optional().describe('Optional ID of the command to undo'),
   // Undo commands typically don't need a selector directly
   selector: z.undefined().optional(),
});
export type UndoCommand = z.infer<typeof UndoCommandSchema>;


// --- Recursive Union Schema Definition ---
// Define the lazy schema first to handle the recursion needed by BatchCommand.
// We need to forward-declare BatchCommandSchema conceptually for the union.
const AICommandSchemaRecursive: z.ZodLazy<z.ZodDiscriminatedUnion<'type', any>> = z.lazy(() =>
  z.discriminatedUnion('type', [
    ClickCommandSchema,
    FillCommandSchema,
    SetAttrCommandSchema,
    BatchCommandSchema, // Reference the BatchCommandSchema defined below
    UndoCommandSchema,
    // Add other command schemas here if needed
  ])
);


// --- Batch Command Schema (Uses the Recursive Definition) ---
export const BatchCommandSchema = BaseAICommandSchema.extend({
    type: z.literal('batch'),
    // Use the lazy recursive schema definition here
    commands: z.array(AICommandSchemaRecursive).describe('An array of commands to execute atomically'),
    // Batch commands typically don't need a selector directly
    selector: z.undefined().optional(),
});


// --- Export Final Schemas and Types ---
export const AICommandSchema = AICommandSchemaRecursive; // Export the lazy schema as the main one

// Infer types after all schemas are defined
export type BatchCommand = z.infer<typeof BatchCommandSchema>;
export type AICommand = z.infer<typeof AICommandSchema>;


// --- Placeholder for Command Execution Logic (if needed here) ---
// This might live entirely within the engine or have specific handlers here.
// For now, we focus on definitions.

// Example Usage (for validation demonstration)
// const exampleCommand: AICommand = { type: 'click', selector: '#myButton' };
// const validationResult = AICommandSchema.safeParse(exampleCommand);
// if (validationResult.success) {
//   console.log('Valid command:', validationResult.data);
// } else {
//   console.error('Invalid command:', validationResult.error);
// }


---
File: /packages/core/src/engine.ts
---

import { AICommand, AICommandSchema, BatchCommand, UndoCommand } from './commands';
import { isValidSelector, parseAndValidateSelector } from './selector';

/**
 * Represents a mutation performed by a command.
 * This is a conceptual representation; the actual structure will depend
 * on the environment (e.g., DOM mutations).
 */
export interface Mutation {
  type: 'attribute' | 'property' | 'style' | 'content' | 'other';
  targetSelector: string; // Selector of the element mutated
  // Information needed to revert the mutation
  previousValue: any;
  currentValue: any;
  attributeName?: string; // For attribute mutations
  // Add other relevant details
}

/**
 * Represents an operation that can undo a specific mutation.
 */
export interface InverseOperation {
  commandId: string; // ID of the command that caused the mutation
  mutation: Mutation; // The mutation to revert
  // Function or data needed to perform the undo
  revert: () => Promise<void> | void; // Placeholder for actual undo logic
}

/**
 * Represents the state required for command execution.
 * This might include the undo stack, current target context (e.g., window/document), etc.
 */
export interface ExecutionContext {
  undoStack: InverseOperation[];
  // Add other context if needed, e.g., target environment access
  // executeMutation: (mutation: Mutation) => Promise<InverseOperation>; // Example
}

/**
 * Error class for execution failures.
 */
export class ExecutionError extends Error {
  constructor(message: string, public command?: AICommand) {
    super(message);
    this.name = 'ExecutionError';
  }
}

/**
 * Processes a single AI command within a given context.
 * This is a placeholder and would delegate to specific handlers
 * in a real execution environment (like @page-ai/dom).
 *
 * @param command The command to execute.
 * @param context The current execution context.
 * @returns A promise resolving to an InverseOperation or null if no mutation occurred.
 * @throws {ExecutionError} If validation or execution fails.
 */
async function executeSingleCommand(
  command: AICommand,
  context: ExecutionContext
): Promise<InverseOperation | null> {
  // 1. Validate the command structure (already done by Zod if parsed)
  // We might re-validate here or assume it's pre-validated.

  // 2. Validate the selector (if applicable)
  if (command.selector && !isValidSelector(command.selector)) {
    throw new ExecutionError(`Invalid selector: ${command.selector}`, command);
  }
  const validatedSelector = command.selector ? parseAndValidateSelector(command.selector) : undefined;


  // 3. Placeholder for actual execution logic based on command.type
  // This would interact with the target environment (DOM, etc.)
  console.log(`Executing command: ${command.type}`, command);

  // --- Placeholder Mutation & Inverse Operation ---
  // In a real scenario, this would be generated by the environment adapter
  let mutation: Mutation | null = null;
  if (command.type === 'fill' || command.type === 'setAttr' || command.type === 'click') {
      // Simulate a mutation for commands that typically cause changes
      mutation = {
          type: command.type === 'setAttr' ? 'attribute' : 'property',
          targetSelector: validatedSelector!,
          previousValue: `old-${command.type}-value`, // Placeholder
          currentValue: command.type === 'fill' ? command.value : (command.type === 'setAttr' ? command.value : 'clicked'), // Placeholder
          attributeName: command.type === 'setAttr' ? command.attribute : undefined,
      };
  }

  if (mutation) {
      const inverseOp: InverseOperation = {
          commandId: command.id || `cmd-${Date.now()}-${Math.random()}`, // Generate ID if missing
          mutation: mutation,
          revert: () => {
              console.log(`Reverting mutation for command ${command.id}`, mutation);
              // Placeholder for actual revert logic
          },
      };
      return inverseOp;
  }
  // --- End Placeholder ---


  return null; // No mutation occurred for this placeholder
}

/**
 * Executes a batch of commands transactionally.
 * If any command fails, it attempts to revert mutations from the successful commands in the batch.
 *
 * @param batchCommand The BatchCommand containing the commands to execute.
 * @param context The execution context.
 * @returns A promise resolving when the batch is processed.
 * @throws {ExecutionError} If any command in the batch fails.
 */
export async function executeBatch(
  batchCommand: BatchCommand,
  context: ExecutionContext
): Promise<void> {
  const successfulInverseOps: InverseOperation[] = [];

  try {
    for (const command of batchCommand.commands) {
      // Validate nested commands (Zod schema handles structure, we check selector)
      if (command.selector && !isValidSelector(command.selector)) {
          throw new ExecutionError(`Invalid selector in batch: ${command.selector}`, command);
      }

      // Process nested batches recursively or handle other command types
      if (command.type === 'batch') {
        await executeBatch(command, context); // Recursive call for nested batches
      } else if (command.type === 'undo') {
        await executeUndo(command, context); // Handle undo within a batch
      } else {
        const inverseOp = await executeSingleCommand(command, context);
        if (inverseOp) {
          successfulInverseOps.push(inverseOp);
        }
      }
    }

    // If all commands succeeded, add their inverse operations to the main undo stack
    context.undoStack.push(...successfulInverseOps);

  } catch (error) {
    console.error('Batch execution failed. Reverting successful steps in batch...', error);
    // Revert successful operations within this batch in reverse order
    for (let i = successfulInverseOps.length - 1; i >= 0; i--) {
      const opToRevert = successfulInverseOps[i];
      if (opToRevert) { // Add check for undefined
          try {
            await opToRevert.revert();
          } catch (revertError) {
            console.error(`Failed to revert operation for command ${opToRevert.commandId}:`, revertError);
            // Decide how to handle revert failures (e.g., log, throw specific error)
          }
      }
    }
    // Re-throw the original error
    if (error instanceof ExecutionError) {
        throw error;
    } else if (error instanceof Error) {
        throw new ExecutionError(`Batch failed: ${error.message}`);
    } else {
        throw new ExecutionError(`Batch failed with unknown error.`);
    }
  }
}

/**
 * Executes an Undo command.
 * Pops the last operation from the undo stack and reverts it.
 *
 * @param undoCommand The UndoCommand.
 * @param context The execution context.
 * @returns A promise resolving when the undo is complete.
 * @throws {ExecutionError} If the undo stack is empty or revert fails.
 */
export async function executeUndo(
    undoCommand: UndoCommand, // Parameter currently unused but kept for consistency
    context: ExecutionContext
): Promise<void> {
    if (context.undoStack.length === 0) {
        console.warn("Undo stack is empty. Cannot perform undo.");
        // Optionally throw an error or just return
        // throw new ExecutionError("Undo stack is empty", undoCommand);
        return;
    }

    const lastOperation = context.undoStack.pop();

    if (lastOperation) {
        try {
            console.log(`Undoing command ${lastOperation.commandId}...`);
            await lastOperation.revert();
        } catch (error) {
            // If revert fails, push the operation back onto the stack? Or log?
            context.undoStack.push(lastOperation); // Put it back for potential retry?
            console.error(`Failed to revert command ${lastOperation.commandId}:`, error);
            const message = error instanceof Error ? error.message : String(error);
            throw new ExecutionError(`Undo failed: ${message}`, undoCommand);
        }
    }
}


/**
 * Main execution function for any AI Command.
 * Parses the command, validates it, and delegates to the appropriate execution logic.
 *
 * @param rawCommand The raw command object (potentially untrusted).
 * @param context The execution context.
 * @returns A promise resolving when the command execution is complete.
 */
export async function executeCommand(
    rawCommand: unknown,
    context: ExecutionContext
): Promise<void> {
    const validationResult = AICommandSchema.safeParse(rawCommand);

    if (!validationResult.success) {
        console.error("Invalid command structure:", validationResult.error);
        throw new ExecutionError(`Invalid command structure: ${validationResult.error.message}`);
    }

    const command = validationResult.data;

    // Delegate based on command type
    switch (command.type) {
        case 'batch':
            await executeBatch(command, context);
            break;
        case 'undo':
            await executeUndo(command, context);
            break;
        case 'click':
        case 'fill':
        case 'setAttr':
            // For single, non-batch/undo commands
            const inverseOp = await executeSingleCommand(command, context);
            if (inverseOp) {
                context.undoStack.push(inverseOp);
            }
            break;
       default:
           // This case should ideally be unreachable if all command types are handled above.
           // If this error occurs at runtime, it means an unknown command type was encountered.
           const unknownType = (command as any)?.type ?? 'unknown';
           console.error("Unhandled command type encountered:", unknownType, command);
           throw new ExecutionError(`Unsupported or unhandled command type: ${unknownType}`);
   }
}

// --- Edge-Runtime Safe Helpers ---

/**
 * Example of an Edge-runtime safe helper.
 * Parses a query string into an object.
 * Avoids using Node.js 'querystring' or 'URLSearchParams' if compatibility is uncertain
 * across all edge environments (though URLSearchParams is generally available).
 * This is a basic implementation.
 *
 * @param queryString The query string (e.g., "foo=bar&baz=qux").
 * @returns An object representing the parsed query string.
 */
export function parseQueryString(queryString: string | undefined | null): Record<string, string> {
    const params: Record<string, string> = {};
    if (!queryString) {
        return params;
    }
    // Remove leading '?' if present
    const query = queryString.startsWith('?') ? queryString.substring(1) : queryString;

   query.split('&').forEach(pair => {
       const parts = pair.split('=');
       // Ensure parts[0] exists before decoding
       if (parts.length > 0 && parts[0] !== undefined) {
           const key = decodeURIComponent(parts[0].replace(/\+/g, ' '));
           // Ensure parts[1] exists for value, otherwise default to empty string
           const value = parts.length > 1 && parts[1] !== undefined
               ? decodeURIComponent(parts[1].replace(/\+/g, ' '))
               : '';
           if (key) { // Avoid empty keys
               params[key] = value;
           }
        }
    });
    return params;
}

// Add other Edge-safe helpers as needed (e.g., simple async delay)

/**
 * Edge-safe async delay function.
 * @param ms Milliseconds to delay.
 */
export function delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
}


---
File: /packages/core/src/index.test.ts
---

describe('Core Package', () => {
  it('should have a placeholder test', () => {
    expect(true).toBe(true);
  });
});


---
File: /packages/core/src/index.ts
---

/**
 * @page-ai/core Entry Point
 *
 * This package provides the core data structures, validation logic,
 * and execution engine primitives for Page AI commands.
 * It is designed to be environment-agnostic and Edge-runtime safe.
 */

// --- Command Definitions ---
export {
    BaseAICommandSchema,
    ClickCommandSchema,
    FillCommandSchema,
    SetAttrCommandSchema,
    BatchCommandSchema,
    UndoCommandSchema,
    AICommandSchema,
} from './commands';

export type {
    BaseAICommand,
    ClickCommand,
    FillCommand,
    SetAttrCommand,
    BatchCommand,
    UndoCommand,
    AICommand,
} from './commands';

// --- Selector Validation ---
export {
    isValidSelector,
    parseAndValidateSelector,
    ALLOWED_SELECTOR_REGEX // Exporting regex might be useful for consumers
} from './selector';

// --- Execution Engine ---
export {
    executeCommand,
    executeBatch,
    executeUndo,
    // ExecutionContext, // Export type separately below
    ExecutionError,
    // Note: InverseOperation and Mutation are internal concepts for now,
    // but could be exported if needed for advanced integration.
    // export type { Mutation, InverseOperation } from './engine';
} from './engine';
export type { ExecutionContext } from './engine'; // Use 'export type'

// --- Edge-Safe Helpers ---
export {
    parseQueryString,
    delay,
} from './engine';


---
File: /packages/core/src/selector.ts
---

/**
 * @module selector
 * Defines a restricted Domain Specific Language (DSL) for CSS-like selectors
 * and provides validation functions to ensure safety against injection attacks.
 *
 * Allowed Grammar:
 * - ID: `#elementId` (alphanumeric, hyphen, underscore)
 * - Class: `.className` (alphanumeric, hyphen, underscore)
 * - Attribute: `[attributeName]` or `[attributeName="value"]` or `[attributeName='value']`
 *   - Attribute names: alphanumeric, hyphen, underscore
 *   - Attribute values: Can be quoted (single or double) or unquoted (if simple).
 *     Quoted values can contain most characters except the quote type used.
 *     Unquoted values are restricted (e.g., alphanumeric, hyphen, underscore).
 * - Combinations: Simple combinations like `#id.class[attr]` are allowed, but complex
 *   combinators (>, +, ~), pseudo-classes (:hover), or pseudo-elements (::before) are NOT allowed.
 * - Whitespace: Leading/trailing whitespace is ignored. Whitespace between simple selectors is NOT allowed.
 */

// Regular expression to validate the restricted selector format.
// Breakdown:
// ^\s*                     - Start, optional leading whitespace
// (                         - Start group for valid selector part
//   #[a-zA-Z0-9_-]+         - ID selector (# followed by allowed chars)
//   |                       - OR
//   \.[a-zA-Z0-9_-]+        - Class selector (. followed by allowed chars)
//   |                       - OR
//   \[                      - Attribute selector start ([)
//     [a-zA-Z0-9_-]+        - Attribute name
//     (?:                   - Optional non-capturing group for value part
//       =                   - Equals sign
//       (?:                 - Non-capturing group for value options
//         "[^"]*"           - Double-quoted value
//         |                 - OR
//         '[^']*'           - Single-quoted value
//         |                 - OR
//         [a-zA-Z0-9_-]+    - Unquoted simple value
//       )
//     )?                    - End optional value part
//   \]                      - Attribute selector end (])
// )+                        - End group for valid selector part, must occur one or more times
// \s*$                      - Optional trailing whitespace, End
export const ALLOWED_SELECTOR_REGEX = /^\s*((#[a-zA-Z0-9_-]+|\.[a-zA-Z0-9_-]+|\[[a-zA-Z0-9_-]+(?:=(?:"[^"]*"|'[^']*'|[a-zA-Z0-9_-]+))?\])+)\s*$/;

/**
 * Validates if a given selector string conforms to the restricted DSL grammar.
 *
 * This function checks if the selector consists only of simple ID, class,
 * or attribute selectors, potentially chained together without complex combinators
 * or pseudo-classes/elements.
 *
 * @param selector - The selector string to validate.
 * @returns `true` if the selector is valid according to the restricted grammar, `false` otherwise.
 * @example
 * isValidSelector("#submit-button"); // true
 * isValidSelector(".user-profile"); // true
 * isValidSelector('[data-testid="login"]'); // true
 * isValidSelector('#main.content[role="article"]'); // true
 * isValidSelector("div > p"); // false (combinator not allowed)
 * isValidSelector("a:hover"); // false (pseudo-class not allowed)
 * isValidSelector("*"); // false (universal selector not allowed)
 * isValidSelector("input[type='text'], button"); // false (comma separation not allowed)
 */
export function isValidSelector(selector: string | undefined | null): boolean {
  if (!selector) {
    // Allow empty/null selectors as they might be optional in commands
    return true;
  }
  if (typeof selector !== 'string') {
    return false;
  }
  // Basic checks for potentially harmful characters or patterns not caught by regex
  if (selector.includes('>') || selector.includes('+') || selector.includes('~') || selector.includes(':') || selector.includes(',')) {
      return false;
  }
  // Check against the restrictive regex
  return ALLOWED_SELECTOR_REGEX.test(selector);
}

/**
 * Parses and validates a selector, throwing an error if invalid.
 *
 * @param selector - The selector string to parse and validate.
 * @returns The validated selector string.
 * @throws {Error} If the selector does not conform to the restricted grammar.
 */
export function parseAndValidateSelector(selector: string): string {
    if (!isValidSelector(selector)) {
        throw new Error(`Invalid selector provided: "${selector}". Only simple ID, class, and attribute selectors are allowed.`);
    }
    // Return the trimmed selector for consistency
    return selector.trim();
}

// Potential future enhancements:
// - A function to break down a valid selector into its components (e.g., { id: '...', classes: [...], attributes: [...] })


---
File: /packages/core/CHANGELOG.md
---

# @page-ai/core

## 0.1.0

### Minor Changes

- Initial version, setting up project and implementing main features



---
File: /packages/core/README.md
---

# @page-ai/core

This package provides the core functionalities for the Page-AI SDK.

## Purpose

*   **Tool Descriptors:** Defines a schema for describing available actions (tools) that an AI agent can perform on a web page.
*   **Selector DSL:** Implements a domain-specific language for selecting DOM elements in a way that's robust to minor UI changes.
*   **Execution Engine:** Handles the execution of commands defined by the tool descriptors against selected elements.
*   **Edge Compatibility:** Designed to be compatible with edge computing environments.

## Installation

While typically installed as part of the main SDK (`@page-ai/react`), you can install it individually if needed:

```bash
bun install @page-ai/core
```

## Basic Usage (Conceptual)

Define command schemas using libraries like Zod to structure the expected inputs and outputs for AI interactions.

```typescript
import { z } from 'zod';

const clickSchema = z.object({
  selector: z.string().describe("CSS selector for the element to click"),
});

// Use this schema within the Page-AI engine to define a 'click' command.
```

The core engine uses these schemas and the selector DSL to interpret AI instructions and interact with the DOM (via `@page-ai/dom`).


---
File: /packages/dom/src/types/domjson.d.ts
---

// Declare the module 'domjson' to satisfy TypeScript
// This provides a basic type definition, assuming the module exports a default object.
// We can refine this later if we know more about the module's structure.
declare module 'domjson' {
  const domjson: any; // Assuming a default export of type 'any'
  export default domjson;
}


---
File: /packages/dom/src/index.test.ts
---

describe('DOM Package', () => {
  it('should have a placeholder test', () => {
    expect(true).toBe(true);
  });
});


---
File: /packages/dom/src/index.ts
---

// Export the core functionalities and types from the @page-ai/dom package

// Re-export from serializer
export { serializeNode } from './serializer';
export type { DomSnapshot } from './serializer';

// Re-export from observer
export { DomObserver } from './observer';
export type { DomPatch, PatchCallback } from './observer';

// Potentially add a higher-level function or class here later
// that combines serialization and observation if needed.
// For now, exporting the building blocks as per requirements.


---
File: /packages/dom/src/observer.ts
---

// Define the structure for DOM patches
// This is a basic structure; we can refine it based on specific needs.
export type DomPatch =
  | { type: 'attributes'; target: string; attributeName: string | null; attributeNamespace: string | null; newValue: string | null; oldValue: string | null }
  | { type: 'childList'; target: string; addedNodes: Node[]; removedNodes: Node[] }
  | { type: 'characterData'; target: string; newValue: string | null; oldValue: string | null };

// Define the callback function type for subscribers
export type PatchCallback = (patches: DomPatch[]) => void;

/**
 * Observes a DOM node for mutations and generates patches.
 */
export class DomObserver {
  private observer: MutationObserver | null = null;
  private callback: PatchCallback;
  private targetNode: Node | null = null;

  constructor(callback: PatchCallback) {
    if (typeof MutationObserver === 'undefined') {
      // Handle environments where MutationObserver is not available (e.g., older browsers, non-browser envs)
      console.error('MutationObserver is not available in this environment.');
      // Potentially throw an error or provide a no-op implementation
      this.callback = () => {}; // No-op callback
      return;
    }
    this.callback = callback;
  }

  /**
   * Starts observing the specified node for mutations.
   * @param target The DOM node to observe.
   * @param options Optional MutationObserver options. Defaults to observing attributes, child list, and subtree character data.
   */
  observe(target: Node, options?: MutationObserverInit): void {
    if (!this.callback || this.observer) {
      // Already observing or no callback set
      this.disconnect(); // Stop previous observer if any
    }

    if (typeof MutationObserver === 'undefined') {
        console.warn('Cannot observe: MutationObserver is not available.');
        return;
    }


    this.targetNode = target;
    const observerOptions: MutationObserverInit = options || {
      attributes: true,
      attributeOldValue: true,
      childList: true,
      characterData: true,
      characterDataOldValue: true,
      subtree: true, // Observe descendants as well
    };

    this.observer = new MutationObserver(this.handleMutations.bind(this));
    this.observer.observe(this.targetNode, observerOptions);
  }

  /**
   * Stops observing mutations.
   */
  disconnect(): void {
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
      this.targetNode = null;
    }
  }

  /**
   * Handles mutation records from the MutationObserver and converts them to patches.
   * @param mutations List of mutation records.
   */
  private handleMutations(mutations: MutationRecord[]): void {
    const patches: DomPatch[] = [];

    // Simple unique identifier generation for nodes (replace with a robust method if needed)
    // This is crucial for identifying the target element in patches.
    // A more robust approach might involve adding unique IDs or using CSS selectors.
    const getNodeIdentifier = (node: Node): string => {
        // Basic example: use tagName and index, or a data attribute if available
        if (node instanceof Element) {
            return node.tagName + (node.id ? `#${node.id}` : ''); // Very basic
        }
        // Handle text nodes, etc. - needs a proper strategy
        return 'node-' + Math.random().toString(36).substring(2, 9); 
    };


    mutations.forEach((mutation) => {
      const targetId = getNodeIdentifier(mutation.target);

      switch (mutation.type) {
        case 'attributes':
          patches.push({
            type: 'attributes',
            target: targetId,
            attributeName: mutation.attributeName,
            attributeNamespace: mutation.attributeNamespace,
            newValue: (mutation.target as Element).getAttribute(mutation.attributeName!),
            oldValue: mutation.oldValue,
          });
          break;
        case 'childList':
          // Note: Converting NodeList to Array for easier handling
          patches.push({
            type: 'childList',
            target: targetId,
            addedNodes: Array.from(mutation.addedNodes),
            removedNodes: Array.from(mutation.removedNodes),
          });
          break;
        case 'characterData':
          patches.push({
            type: 'characterData',
            target: targetId, // Target for characterData is the Text node itself
            newValue: mutation.target.nodeValue,
            oldValue: mutation.oldValue,
          });
          break;
      }
    });

    if (patches.length > 0) {
      this.callback(patches);
    }
  }
}


---
File: /packages/dom/src/serializer.ts
---

import domjson from 'domjson';

// Define a type for the snapshot. Using 'any' for now as domJSON's specific type isn't readily available.
// We can refine this later if needed.
export type DomSnapshot = any; 

/**
 * Serializes a DOM node and its descendants into a JSON representation.
 * @param node The root DOM node to serialize.
 * @returns The JSON representation of the DOM node.
 */
export function serializeNode(node: Node): DomSnapshot {
  if (!(node instanceof Element || node instanceof Document || node instanceof DocumentFragment)) {
    console.warn('serializeNode expects an Element, Document, or DocumentFragment. Received:', node);
    // Handle non-element nodes appropriately, maybe return null or a specific structure
    return null; 
  }
  // domJSON might require specific options, using defaults for now.
  return domjson.toJSON(node);
}


---
File: /packages/dom/CHANGELOG.md
---

# @page-ai/dom

## 0.1.0

### Minor Changes

- Initial version, setting up project and implementing main features



---
File: /packages/dom/README.md
---

# @page-ai/dom

This package handles interaction with the browser's Document Object Model (DOM) for the Page-AI SDK.

## Purpose

*   **DOM Serialization:** Provides mechanisms to serialize the relevant parts of the DOM into a format that AI models can understand.
*   **MutationObserver Diffing:** Uses `MutationObserver` to efficiently detect changes in the DOM and generate concise diffs, minimizing the data sent to the AI model.

## Installation

While typically installed as part of the main SDK (`@page-ai/react`), you can install it individually if needed:

```bash
bun install @page-ai/dom
```

## Basic Usage (Conceptual)

Initialize the DOM observer to monitor changes within a specific part of the application.

```typescript
import { DomObserver } from '@page-ai/dom';

// Get the root element of your application
const appRoot = document.getElementById('root');

if (appRoot) {
  // Initialize the observer, potentially passing configuration options
  const observer = new DomObserver(appRoot, { /* options */ });

  // Start observing
  observer.start();

  // Listen for changes
  observer.onChange((diff) => {
    console.log('DOM changed:', diff);
    // Send the diff to the AI agent or core engine
  });

  // Remember to stop observing when the component unmounts
  // observer.stop();
}
```

The serialized DOM and subsequent diffs are used by `@page-ai/core` to provide context to the AI agent.


---
File: /packages/react/src/components/AIDevTools.tsx
---

'use client'; // This component interacts with context and state, likely client-side

import React from 'react';
import { usePageAI } from '../hooks';

const devToolsStyles: React.CSSProperties = {
  position: 'fixed',
  bottom: '10px',
  right: '10px',
  width: '350px',
  maxHeight: '40vh',
  backgroundColor: 'rgba(0, 0, 0, 0.8)',
  color: '#fff',
  border: '1px solid #555',
  borderRadius: '5px',
  padding: '10px',
  zIndex: 9999,
  overflow: 'auto',
  fontSize: '12px',
  fontFamily: 'monospace',
  display: 'flex',
  flexDirection: 'column',
};

const headerStyles: React.CSSProperties = {
  display: 'flex',
  justifyContent: 'space-between',
  alignItems: 'center',
  borderBottom: '1px solid #555',
  paddingBottom: '5px',
  marginBottom: '5px',
};

const closeButtonStyles: React.CSSProperties = {
  background: 'none',
  border: 'none',
  color: '#aaa',
  fontSize: '16px',
  cursor: 'pointer',
};

const contentStyles: React.CSSProperties = {
  flexGrow: 1,
  overflowY: 'auto', // Allow content scrolling
};

const sectionStyles: React.CSSProperties = {
  marginBottom: '10px',
};

const sectionTitleStyles: React.CSSProperties = {
  fontWeight: 'bold',
  color: '#88f',
  marginBottom: '5px',
};

/**
 * A developer tools overlay component that displays the current Page-AI
 * snapshot and patches when enabled via the context.
 */
export const AIDevTools: React.FC = () => {
  const { snapshot, patches, isDevToolsEnabled, toggleDevTools } = usePageAI();

  if (!isDevToolsEnabled) {
    return null; // Don't render anything if not enabled
  }

  // Simple serialization for display
  const formatData = (data: any) => {
    try {
      return JSON.stringify(data, null, 2);
    } catch (e) {
      return `Error serializing data: ${e instanceof Error ? e.message : String(e)}`;
    }
  };

  return (
    <div style={devToolsStyles}>
      <div style={headerStyles}>
        <span>Page-AI DevTools</span>
        <button onClick={toggleDevTools} style={closeButtonStyles} title="Close DevTools">&times;</button>
      </div>
      <div style={contentStyles}>
        <div style={sectionStyles}>
          <div style={sectionTitleStyles}>Snapshot:</div>
          <pre>{snapshot ? formatData(snapshot) : 'No snapshot yet.'}</pre>
        </div>
        <div style={sectionStyles}>
          <div style={sectionTitleStyles}>Patches ({patches.length}):</div>
          <pre>{patches.length > 0 ? formatData(patches) : 'No patches yet.'}</pre>
        </div>
      </div>
    </div>
  );
};


---
File: /packages/react/src/components/ClientWrapper.tsx
---

'use client'; // Mark this component as a Client Component

import React, { ReactNode } from 'react';
import { PageAIProvider } from '../context';

// Re-export props type for convenience if needed, or define inline
interface ClientWrapperProps {
  children: ReactNode;
  observerOptions?: MutationObserverInit;
  rootElement?: Element | Document | DocumentFragment;
  enableDevToolsQueryParam?: string;
  // Add engineOptions here if/when CommandEngine is integrated
}

/**
 * A client-side wrapper component for easy integration with frameworks
 * like Next.js (RSC). It ensures that the PageAIProvider and its
 * associated hooks and effects run only on the client.
 *
 * It accepts the same props as PageAIProvider and passes them through.
 */
export const ClientWrapper: React.FC<ClientWrapperProps> = ({
  children,
  ...providerProps // Pass remaining props directly to PageAIProvider
}) => {
  return (
    <PageAIProvider {...providerProps}>
      {children}
    </PageAIProvider>
  );
};


---
File: /packages/react/src/context.tsx
---

import React, { createContext, useContext, useEffect, useState, useRef, ReactNode, useCallback } from 'react';
import { DomObserver, serializeNode } from '@page-ai/dom';
import type { DomPatch, DomSnapshot } from '@page-ai/dom';
// import { CommandEngine, CommandEngineOptions } from '@page-ai/core/src/engine'; // Placeholder

export interface PageAIContextValue { // Export the interface
  snapshot: DomSnapshot | null;
  patches: DomPatch[];
  // callTool?: CommandEngine['callTool']; // Placeholder
  isDevToolsEnabled: boolean;
  toggleDevTools: () => void;
}

const PageAIContext = createContext<PageAIContextValue | undefined>(undefined);

interface PageAIProviderProps {
  children: ReactNode;
  observerOptions?: MutationObserverInit; // Use standard MutationObserverInit
  rootElement?: Element | Document | DocumentFragment; // Allow specifying root
  // engineOptions?: CommandEngineOptions; // Placeholder
  enableDevToolsQueryParam?: string; // e.g., 'debugAI'
}

export const PageAIProvider: React.FC<PageAIProviderProps> = ({
  children,
  observerOptions,
  rootElement = document.body, // Default to document.body
  // engineOptions,
  enableDevToolsQueryParam = 'debugAI',
}: PageAIProviderProps) => {
  const [snapshot, setSnapshot] = useState<DomSnapshot | null>(null);
  const [patches, setPatches] = useState<DomPatch[]>([]);
  const [isDevToolsEnabled, setIsDevToolsEnabled] = useState(false);
  const observerRef = useRef<DomObserver | null>(null);
  // const engineRef = useRef<CommandEngine | null>(null); // Placeholder

  // Callback for the DomObserver
  const handlePatches = useCallback((newPatches: DomPatch[]) => {
    // console.log('PageAIProvider: Received patches:', newPatches);
    setPatches((prevPatches: DomPatch[]) => [...prevPatches, ...newPatches]); // Append new patches
  }, []);

  useEffect(() => {
    // Initialize Observer with the callback
    observerRef.current = new DomObserver(handlePatches);
    // engineRef.current = new CommandEngine(engineOptions); // Placeholder

    // Get initial snapshot
    console.log('PageAIProvider: Generating initial snapshot...');
    const initialSnapshot = serializeNode(rootElement);
    setSnapshot(initialSnapshot);
    setPatches([]); // Clear patches on new snapshot

    // Start observing
    console.log('PageAIProvider: Starting observer...');
    observerRef.current.observe(rootElement, observerOptions);

    // Check for dev tools query param
    const checkDevToolsParam = () => {
      if (typeof window !== 'undefined' && enableDevToolsQueryParam) {
        const params = new URLSearchParams(window.location.search);
        setIsDevToolsEnabled(params.has(enableDevToolsQueryParam));
      }
    };

    checkDevToolsParam();
    // Optionally listen for history changes if using SPA routing
    // window.addEventListener('popstate', checkDevToolsParam);

    return () => {
      console.log('PageAIProvider: Disconnecting observer...');
      observerRef.current?.disconnect();
      // window.removeEventListener('popstate', checkDevToolsParam);
    };
    // Ensure dependencies are correct
  }, [observerOptions, rootElement, enableDevToolsQueryParam, handlePatches]); // engineOptions

  const toggleDevTools = () => {
    setIsDevToolsEnabled((prev: boolean) => !prev);
    // Optionally update URL query param here if desired
  };

  const contextValue: PageAIContextValue = {
    snapshot,
    patches,
    // callTool: engineRef.current?.callTool.bind(engineRef.current), // Placeholder
    isDevToolsEnabled,
    toggleDevTools,
  };

  return (
    <PageAIContext.Provider value={contextValue}>
      {children}
    </PageAIContext.Provider>
  );
};

// Custom hook to use the context (no changes needed here)
export const usePageAIContext = (): PageAIContextValue => {
  const context = useContext(PageAIContext);
  if (context === undefined) {
    throw new Error('usePageAIContext must be used within a PageAIProvider');
  }
  return context;
};


---
File: /packages/react/src/hooks.ts
---

import { usePageAIContext } from './context';

/**
 * Hook to access the Page-AI context.
 *
 * Provides access to the latest DOM snapshot, streamed patches,
 * and developer tools state.
 *
 * Must be used within a `<PageAIProvider>`.
 *
 * @returns The Page-AI context value.
 */
export const usePageAI = () => {
  // Directly use the context hook defined alongside the provider
  return usePageAIContext();
};


---
File: /packages/react/src/index.test.tsx
---

describe('React Package', () => {
  it('should have a placeholder test', () => {
    expect(true).toBe(true);
  });
});


---
File: /packages/react/src/index.ts
---

// Core Provider and Context Hook
export { PageAIProvider, usePageAIContext } from './context'; // Export context hook for advanced use cases if needed
export type { PageAIContextValue } from './context'; // Export context type

// Primary Hook
export { usePageAI } from './hooks';

// Components
export { ClientWrapper } from './components/ClientWrapper';
export { AIDevTools } from './components/AIDevTools';

// Re-export relevant types from dependencies if needed for consumers
// Consumers should use the standard MutationObserverInit type from lib.dom.d.ts
export type { DomSnapshot, DomPatch } from '@page-ai/dom';


---
File: /packages/react/CHANGELOG.md
---

# @page-ai/react

## 0.3.0

### Minor Changes

- Working on issue that prevents installation

## 0.2.0

### Minor Changes

- Patch bug where packages can't be found.

## 0.1.0

### Minor Changes

- Initial version, setting up project and implementing main features

### Patch Changes

- Updated dependencies
  - @page-ai/core@0.1.0
  - @page-ai/dom@0.1.0



---
File: /packages/react/README.md
---

# @page-ai/react

This package provides React components and hooks to integrate the Page-AI SDK into React applications.

## Purpose

*   **React Integration:** Offers seamless integration with React applications.
*   **Provider Component:** Includes `PageAIProvider` (and potentially `ClientWrapper` for specific use cases like Next.js Client Components) to manage the Page-AI context.
*   **`usePageAI` Hook:** Provides easy access to Page-AI functionalities within React components.
*   **`AIDevTools` Component:** A development tool component for visualizing Page-AI state and interactions.

## Installation

Install the package along with its core and DOM dependencies:

```bash
bun install @page-ai/react @page-ai/core @page-ai/dom
```

## Basic Usage

**1. Wrap your application:**

Use `PageAIProvider` (or `ClientWrapper` if needed for client-side boundaries) at the root of your application or relevant subtree.

```jsx
// In your main App component or layout
import { PageAIProvider } from '@page-ai/react';
import { MyAppComponent } from './MyAppComponent';

function App() {
  return (
    <PageAIProvider config={{ /* configuration options */ }}>
      <MyAppComponent />
      {/* Optionally include DevTools during development */}
      {process.env.NODE_ENV === 'development' && <AIDevTools />}
    </PageAIProvider>
  );
}

export default App;
```

**2. Access Page-AI in components:**

Use the `usePageAI` hook to interact with the Page-AI engine.

```jsx
import { usePageAI } from '@page-ai/react';

function MyInteractiveComponent() {
  const { engine, state } = usePageAI();

  // Use the engine to execute commands or get information
  // Access the current state (e.g., serialized DOM, available tools)

  return (
    <div>
      {/* Your component UI */}
    </div>
  );
}
```

**3. Enable DevTools (Development):**

Include the `AIDevTools` component within the provider during development to inspect the Page-AI state.


---
File: /eslint.config.js
---

const globals = require('globals');
const typescriptParser = require('@typescript-eslint/parser');
// Note: Full migration might require importing plugins and configs directly.
// Example: const js = require("@eslint/js");

module.exports = [
  {
    // languageOptions apply globally unless overridden
    languageOptions: {
      parser: typescriptParser,
      parserOptions: {
        ecmaVersion: 'latest',
        sourceType: 'module',
        ecmaFeatures: {
          jsx: true,
        },
      },
      globals: {
        ...globals.browser,
        ...globals.node,
        ...globals.es2021,
      },
    },
    // plugins: { /* Plugin definitions needed for flat config */ },
    // extends: [ /* Extends are handled differently, often via imported config objects */ ],
    settings: { // Settings might need adjustment based on plugins
      react: {
        version: 'detect',
      },
    },
    rules: {
      // Rules from 'extends' might need to be added explicitly or via imported configs
      'react/prop-types': 'off', // Keep specific rules
    },
    // ignores replaces ignorePatterns
    ignores: [
      'node_modules/',
      'dist/',
      'build/',
      '.turbo/',
      '.changeset/',
      'coverage/',
      '*.log',
      '*.lock',
      '!.changeset/config.json',
      'eslint.config.js', // Ignore the config file itself
    ],
  },
  // Overrides become separate objects in the array
  {
    files: ['*.test.ts', '*.test.tsx'],
    languageOptions: {
      globals: {
        ...globals.jest,
      },
    },
    // Add test-specific rules/plugins if needed
  },
  {
    files: ['jest.config.js', '*.config.js', '*.config.ts'], // Removed .eslintrc.js reference
    languageOptions: {
      globals: {
        ...globals.node, // Keep node env for config files
      },
    },
  },
];


---
File: /jest.config.js
---

/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node', // Default environment
  projects: [
    // Core package (Node environment)
    {
      displayName: 'core',
      preset: 'ts-jest',
      rootDir: '<rootDir>/packages/core',
      testEnvironment: 'node',
      moduleNameMapper: {
        // Map workspace dependencies to their source for tests if needed
        // Example: '^@page-ai/core/(.*)$': '<rootDir>/src/$1',
        // Or map to dist if testing built code:
        '^@page-ai/core$': '<rootDir>/src/index.ts', // Adjust if needed
      },
      testMatch: ['<rootDir>/src/**/*.test.ts'],
    },
    // DOM package (JSDOM environment)
    {
      displayName: 'dom',
      preset: 'ts-jest',
      rootDir: '<rootDir>/packages/dom',
      testEnvironment: 'jsdom',
      moduleNameMapper: {
        '^@page-ai/core$': '<rootDir>/../core/src/index.ts', // Map core dependency
        '^@page-ai/dom$': '<rootDir>/src/index.ts',
      },
      testMatch: ['<rootDir>/src/**/*.test.ts'],
    },
    // React package (JSDOM environment)
    {
      displayName: 'react',
      preset: 'ts-jest',
      rootDir: '<rootDir>/packages/react',
      testEnvironment: 'jsdom',
      moduleNameMapper: {
        '^@page-ai/core$': '<rootDir>/../core/src/index.ts', // Map core dependency
        '^@page-ai/dom$': '<rootDir>/../dom/src/index.ts',   // Map dom dependency
        '^@page-ai/react$': '<rootDir>/src/index.ts',
        // Handle CSS modules or other assets if needed
        '\\.(css|less|scss|sass)$': 'identity-obj-proxy',
      },
      testMatch: ['<rootDir>/src/**/*.test.ts', '<rootDir>/src/**/*.test.tsx'],
      // Add setup file if needed for React Testing Library etc.
      // setupFilesAfterEnv: ['<rootDir>/src/setupTests.ts'],
    },
  ],
  // Optional: Collect coverage
  // collectCoverage: true,
  // coverageDirectory: '<rootDir>/coverage/',
  // coverageReporters: ['json', 'lcov', 'text', 'clover'],
  // collectCoverageFrom: [
  //   'packages/*/src/**/*.{ts,tsx}',
  //   '!packages/*/src/**/*.d.ts',
  //   '!packages/*/src/**/*.test.{ts,tsx}',
  //   '!packages/*/src/index.{ts,tsx}', // Often excluded
  // ],
};


---
File: /README.md
---

# Page-AI SDK

Page-AI enables AI agents to interact with web applications by providing a structured way to describe UI elements and actions, observe DOM changes, and execute commands. It aims to bridge the gap between AI models and the dynamic nature of web interfaces.

## Packages

This monorepo contains the following packages:

*   `@page-ai/core`: Core engine, command definitions, selector DSL, and Edge compatibility.
*   `@page-ai/dom`: DOM serialization and MutationObserver-based diffing.
*   `@page-ai/react`: React integration components and hooks.

## Installation

Install the necessary packages using your preferred package manager. For example, with Bun:

```bash
bun add @page-ai/react @page-ai/core @page-ai/dom
```

## Development Commands

This section details the scripts available in the root `package.json` for common development tasks:

*   **`bun run build`**: Builds all packages (`@page-ai/core`, `@page-ai/dom`, `@page-ai/react`) sequentially. This process compiles the source code (TypeScript) into distributable JavaScript files, typically placing them in the `dist` directory within each package.

*   **`bun run add-changeset`**: Initiates the [Changesets](https://github.com/changesets/changesets) workflow to document changes (e.g., bug fixes, new features) intended for the next release. It interactively prompts you to select the packages affected by your changes and provide a description. This creates a unique markdown file in the `.changeset` directory detailing the change.

*   **`bun run version`**: Consumes the markdown files generated by `bun run add-changeset`. It automatically calculates the next appropriate semantic version (SemVer) for each affected package based on the changesets, updates the `version` field in their respective `package.json` files, and updates the `CHANGELOG.md` file for each package.

*   **`bun run publish`**: Publishes the packages to the NPM registry. This command first executes the `bun run build` script to ensure the latest code is built. Then, it publishes only the packages that have been versioned (by `bun run version`) since the last publish. *Note: Requires you to be logged into NPM (`npm login`) with appropriate permissions.*

*   **`bun run dev`**: Currently a placeholder script (`echo "Starting dev..."`). This can be configured to run a specific development workflow, such as starting a local development server for a demo application, watching files for changes and rebuilding, or other common development tasks.

*   **`bun run lint`**: Runs ESLint across the entire monorepo (`.ts` and `.tsx` files). This checks the code for potential errors, enforces code style consistency, and helps maintain code quality according to the rules defined in the ESLint configuration (`.eslintrc.js`).

*   **`bun run test`**: Executes the Jest test suite for all packages. It looks for test files (typically `*.test.ts` or `*.test.tsx`) within each package and runs the tests defined within them, reporting the results.
## Release Process (Using Changesets)

This project uses [Changesets](https://github.com/changesets/changesets) to manage versioning, changelogs, and publishing. Follow these steps carefully to prepare and publish a new release:

1.  **Make Code Changes:** Implement your features, bug fixes, or other changes in the relevant package(s).
2.  **Ensure Quality (Recommended):**
    *   Run tests: `bun run test`
    *   Run the linter: `bun run lint`
    *   Address any failures before proceeding.
3.  **Document Changes:** For *each* distinct change that should appear in the changelog, run:
    ```bash
    bun run add-changeset
    ```
    *   Follow the prompts to select affected packages, choose the SemVer bump (patch, minor, major), and write a clear description for the changelog.
4.  **Commit Changesets:** Add the generated markdown files in the `.changeset` directory to Git:
    ```bash
    git add .changeset/
    git commit -m "docs: add changesets for upcoming release"
    ```
5.  **Version Packages:** Run the version command to consume changesets, update package versions, and generate changelogs:
    ```bash
    bun run version
    ```
    *   This updates `package.json` versions and `CHANGELOG.md` files based on the committed changesets.
    *   **Note on Internal Dependencies:** If you use the `workspace:*` protocol for internal dependencies (e.g., `@page-ai/core": "workspace:*"` in `@page-ai/react`'s `package.json`), the `bun run version` command will automatically replace `workspace:*` with the correct fixed version (e.g., `^0.1.1`) of the dependency *if* that dependency is also being versioned in the same release. This ensures the correct versions are written to `package.json` before you commit.
    *   **Important:** This `version` step must be completed and the resulting changes (updated `package.json` and `CHANGELOG.md` files) must be committed *before* building and publishing. This prevents the `workspace:` protocol from being published to NPM.
6.  **Review and Commit Versioning:**
    *   Review the changes made to `package.json` and `CHANGELOG.md` files to ensure they are correct.
    *   Commit these changes:
        ```bash
        git add packages/*/package.json packages/*/CHANGELOG.md .changeset/pre.json # Adjust if other files were changed by the version command
        git commit -m "chore: bump versions and update changelogs"
        ```
7.  **Build Packages:** Ensure all packages are built with the latest code and correct version numbers before publishing:
    ```bash
    bun run build
    ```
8.  **Publish Packages (Manual):** Publish the newly versioned packages to NPM. This step requires you to be logged into NPM (`npm login`) with appropriate permissions.
    ```bash
    bunx changeset publish
    ```
9.  **Tag Release (Optional but Recommended):** Create and push a Git tag for the release.
    ```bash
    # Example: git tag @page-ai/core@0.1.1 # Tag specific package version
    # Example: git tag release-2025-05-05
    # git push origin <tag_name> # Or git push --tags
    ```

This structured process ensures accurate versioning, automated changelogs, and a clear separation between versioning (`bun run version`), building (`bun run build`), and publishing (`changeset publish`).
